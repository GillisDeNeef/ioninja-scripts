//.............................................................................
//
// $(pluginName) stream
//

//.............................................................................

class $(streamClass)
{
protected:
	enum State
	{
		Idle,
		Command,
	}
	
	State m_state;
	char m_commandBuffer [256];
    size_t m_commandSize;

public:
	write (
		log.Writer* writer,
		uint64_t timestamp,
		uint_t recordCode,
		void const* p,
		size_t size
		);
		
protected:
    appendCommand (
        void const* p,
		size_t size
        );	
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

$(streamClass).write (
	log.Writer* writer,
	uint64_t timestamp,
	uint_t recordCode,
	void const* p,
	size_t size
	)
{
	void const* p0 = p;		
	void const* end = p + size;	

	for (; p < end; p++)
	{
		switch (m_state)
		{
		case State.Idle:
			void const* p2 = memchr (p, '<', end - p);
			if (!p2)
				break2;

			m_state = State.Command;
			p = (char const*) p2 + 1;
			
			// and fall through 
			
		case State.Command:
			void const* p2 = memchr (p, '>', end - p);
			if (!p2)
			{
				appendCommand (p, end - p);
				break2;			
			}
			
			appendCommand (p, p2 - p);			
			p = (char const*) p2 + 1;
			
			writer.write (timestamp, recordCode, p0, p - p0);
			writer.write (timestamp, $(logRecordCodeEnum).InBandCommand, m_commandBuffer, m_commandSize);
			
			p0 = p;
			m_commandSize = 0;
			m_state = State.Idle;
			break;
		}
	}
	
	writer.write (timestamp, recordCode, p0, end - p0);
}

$(streamClass).appendCommand (
    void const* p,
    size_t size
    )
{
	size_t leftover = sizeof (m_commandBuffer) - 1 - m_commandSize;
	if (!leftover)
		return;

	if (size > leftover)
		size = leftover;

	memcpy (&m_commandBuffer [m_commandSize], p, size);
	m_commandSize += size;
}

//.............................................................................
