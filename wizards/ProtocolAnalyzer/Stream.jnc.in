//.............................................................................
//
// $(pluginName) stream
//

//.............................................................................

class $(streamClass)
{
protected:
	jnc.Recognizer m_scanner;

	log.Writer* m_writer;
	uint64_t m_timestamp;
	uint_t m_recordCode;
	void const* m_p;
	size_t m_offset;

public:
	construct ()
	{
		m_scanner.construct (scanStream);
	}

	write (
		log.Writer* writer,
		uint64_t timestamp,
		uint_t recordCode,
		void const* p,
		size_t size
		);
		
protected:
	bool automaton scanStream ();
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

$(streamClass).write (
	log.Writer* writer,
	uint64_t timestamp,
	uint_t recordCode,
	void const* p,
	size_t size
	)
{
	// prepare context for scanner automaton

	m_writer = writer;
	m_timestamp = timestamp;
	m_recordCode = recordCode;
	m_p = p;
	m_offset = m_scanner.m_currentOffset;
	
	try m_scanner.write (p, size);

	// display the rest of actual data

	size_t chunkLength = m_scanner.m_currentOffset - m_offset;

	if (chunkLength)
		writer.write (timestamp, recordCode, m_p, chunkLength);
}

bool automaton $(streamClass).scanStream ()
{
	%% '<' [^>]* '>'
		// display the actual data first...
			
		size_t chunkLength = recognizer.m_currentOffset - m_offset;
		assert (chunkLength); // matched lexeme is not empty
		
		m_writer.write (m_timestamp, m_recordCode, m_p, chunkLength);

		m_p += chunkLength;
		m_offset += chunkLength;

		// ...and then the inband command
		
		m_writer.write (
			m_timestamp, 
			$(logRecordCodeEnum).InBandCommand, 
			recognizer.m_lexeme + 1, 
			recognizer.m_lexemeLength - 2
			);
	
	%% .
		// ignore the rest		
}

//.............................................................................
