//..............................................................................
//
// TCP sequencer ensures handling of TCP segments in correct order
//

import "std_List.jnc"

//..............................................................................

class TcpSequencer
{
	enum Defaults
	{
		OutOfSeqLimit = 8
	}

protected:
	struct OutOfSeqSegment
	{
		OutOfSeqSegment* m_next;
		uint32_t m_seqNumber;
		void* m_p;
		size_t m_size;
	}

	log.Writer*	m_logWriter;
	std.List m_outOfSeqList;

public:
	size_t m_outOfSeqLimit;
	uint32_t m_seqNumber;
	uint64_t m_logRecordCode;

public:
	construct(doc.PluginHost* pluginHost);

	write(
		uint32_t seqNumber,
		void const* p,
		size_t size
		);

protected:
	addOutOfSeqSegment(
		uint32_t seqNumber,
		void const* p,
		size_t size
		);

	writeInSeqSegment(
		uint32_t seqNumber,
		void const* p,
		size_t size
		);

	writeAlignedOutOfSeqSegments();
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

TcpSequencer.construct(doc.PluginHost* pluginHost)
{
	m_logWriter = pluginHost.m_log.m_writer;
	m_outOfSeqLimit = Defaults.OutOfSeqLimit;
}

TcpSequencer.write(
	uint32_t seqNumber,
	void const* p,
	size_t size
	)
{
	if ((intptr_t)(seqNumber - m_seqNumber) > 0)
	{
		addOutOfSeqSegment(seqNumber, p, size);
	}
	else
	{
		writeInSeqSegment(seqNumber, p, size);
		writeAlignedOutOfSeqSegments();
	}
}

TcpSequencer.addOutOfSeqSegment(
	uint32_t seqNumber,
	void const* p,
	size_t size
	)
{
	// find location to insert it

	std.ListEntry* it = m_outOfSeqList.m_head;
	for (; it; it = it.m_next)
	{
		OutOfSeqSegment* segment = it.m_data;
		if (segment.m_seqNumber == seqNumber)
		{
			if (size > segment.m_size)
			{
				segment.m_p = new char[size];
				segment.m_size = size;
				memcpy(segment.m_p, p, size);
			}

			return;
		}

		if ((int32_t)(seqNumber - segment.m_seqNumber) <= 0)
			break;
	}

	OutOfSeqSegment* segment = new OutOfSeqSegment;
	segment.m_seqNumber = seqNumber;
	segment.m_p = new char[size];
	segment.m_size = size;
	memcpy(segment.m_p, p, size);

	m_outOfSeqList.insertBefore(segment, it);
	if (m_outOfSeqList.m_count < m_outOfSeqLimit)
		return;

	m_logWriter.write(TcpFlowMonLogRecordCode.OutOfOrderDataDropped);

	// maintain out-of-seq limit

	while (m_outOfSeqList.m_count > m_outOfSeqLimit)
	{
		OutOfSeqSegment* segment = m_outOfSeqList.removeHead();
		writeInSeqSegment(segment.m_seqNumber, segment.m_p, segment.m_size);
	}

	writeAlignedOutOfSeqSegments();
}

TcpSequencer.writeInSeqSegment(
	uint32_t seqNumber,
	void const* p,
	size_t size
	)
{
	if ((int32_t)(seqNumber - m_seqNumber) < 0) // retransmission
	{
		size_t skip = m_seqNumber - seqNumber;
		if (skip >= size)
			return;

		p += skip;
		size -= skip;
	}

	m_logWriter.write(m_logRecordCode, p, size);
	m_seqNumber += size;
}

TcpSequencer.writeAlignedOutOfSeqSegments()
{
	while (m_outOfSeqList.m_count)
	{
		OutOfSeqSegment* segment = m_outOfSeqList.m_head.m_data;
		if ((int32_t)(segment.m_seqNumber - m_seqNumber) > 0)
			break;

		m_outOfSeqList.removeHead();
		writeInSeqSegment(segment.m_seqNumber, segment.m_p, segment.m_size);
	}
}

//..............................................................................
