//.............................................................................
//
// TCP Monitor session
//

import "doc_Plugin.jnc"
import "io_PCap.jnc"
import "io_Packet.jnc"
import "io_SocketAddress.jnc"

//.............................................................................

class TcpFlowMonSession: doc.Session
{
protected:
	bitflag enum State
	{
		Resolving,
		Capturing,
		TcpConnection,
		TcpSyn,
	}

	enum ActionId
	{
		Capture,
		_Count,
	}

	enum IconId
	{
		Capture,
		StopCapture,
		_Count,
	}

	enum StatusPaneId
	{
		State,
		_Count, 
	}

	struct TcpOutOfOrderSegment
	{
		TcpOutOfOrderSegment* m_next;
		uint32_t m_seqNumber;
		void* m_p;
		size_t m_size;
	};	

	struct TcpPeer
	{
		log.StdRecordCode m_recordCode;
		io.SocketAddress m_address;
		uint32_t m_seqNumber;
		TcpOutOfOrderSegment* m_outOfOrderSegment;
		size_t m_outOfOrderSegmentCount;
	};	

protected:
	State bindable m_state;

	// pcap & tcp decoding

	io.PCap* m_pcap;	
	io.SocketAddressResolver* m_resolver;
	io.SocketAddress m_filterAddress;
	TcpPeer m_tcpPeer1;
	TcpPeer m_tcpPeer2;
	
	// toolbar, status bar & menu
	
	gui.Action* m_actionTable [ActionId._Count];
	gui.Icon* m_iconTable [IconId._Count];
	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
	gui.ComboBox* m_deviceCombo;
	gui.ComboBox* m_filterCombo;
	
	// property grid
	
	gui.StringProperty* m_deviceProp;
	gui.BoolProperty* m_promisciousProp;
	gui.StringProperty* m_filterProp;
	gui.IntProperty* m_outOfOrderLimitProp;

public:
	construct (doc.PluginHost* pluginHost);

	bool capture () throws;
	bool capture (io.SocketAddress const* filterAddress) throws;
	stopCapture ();

	override void load (doc.Storage* storage);
	override void save (doc.Storage* storage);
	override void updateProperties ();
	override bool applyProperties () throws;
	override void restoreDefaultProperties ();

protected:
	onCapture ();	
	onSetFilter ();
	onReadyRead (uint_t syncId);
	onResolverEvent (io.SocketAddressResolverEventParams const* params);

	char const* createFilterString (io.SocketAddress const* filterAddress);

	bool applyFilter () throws;
	bool setFilter (io.SocketAddress const* filterAddress) throws;

	bool decodePacket (
		void const* p,
		size_t size
		);

	decodeTcpPacket (
		TcpPeer* peer,		
		io.TcpHdr const* tcpHdr,
		void const* p,
		size_t size
		);

	decodeTcpDataSegment (
		TcpPeer* peer,
		uint32_t seqNumber,
		void const* p,
		size_t size
		);

	writeTcpData (
		TcpPeer* peer,
		uint32_t seqNumber,
		void const* p,
		size_t size
		);

	addTcpOutOfOrderSegment (
		TcpPeer* peer,
		uint32_t seqNumber,
		void const* p,
		size_t size
		);

	writeFirstTcpOutOfOrderSegment (TcpPeer* peer);
	writeAlignedTcpOutOfOrderSegments (TcpPeer* peer);

	createUi ();
	reactor m_uiReactor ();
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

TcpFlowMonSession.construct (doc.PluginHost* pluginHost)
{
	basetype.construct (pluginHost);

	pluginHost.m_log.m_representerFunc = representTcpFlowMonLog;

	m_state = 0;
	m_pcap = new io.PCap ();
	m_pcap.m_onReadyRead += onReadyRead @ m_pluginHost.m_mainThreadScheduler;
	m_resolver = new io.SocketAddressResolver ();
	m_resolver.m_onResolverEvent += onResolverEvent @ m_pluginHost.m_mainThreadScheduler;
	m_tcpPeer1.m_recordCode = log.StdRecordCode.Rx;
	m_tcpPeer2.m_recordCode = log.StdRecordCode.Tx;
	
	createUi ();
}

TcpFlowMonSession.createUi ()
{
	// toolbar

	m_pluginHost.m_toolBar.addLabel ("Device:");
	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
	m_deviceCombo.m_onEnter += onCapture;

	m_pluginHost.m_toolBar.addLabel ("Filter:");
	m_filterCombo = m_pluginHost.m_toolBar.addComboBox (-1);
	m_filterCombo.m_isEditable = true;
	m_filterCombo.m_onEnter += onSetFilter;

	io.PCapDeviceDesc const* device = io.createPCapDeviceDescList ();

	for (; device; device = device->m_next)
	{
		char const* itemName = $"%1 (%2)" (
			device->m_description ? device->m_description : device->m_name,
			device->m_address.m_address.getString ()
			);

		m_deviceCombo.addItem (itemName, device);
	}

	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");

	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;

	// status bar
	
	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);

	// property grid

	m_deviceProp = m_pluginHost.m_propertyGrid.createStringProperty (
		"Device",
		"Specify the device to capture on"
		);

	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty (
		"Promiscious Mode",
		"Put the capturing interface into promiscious mode"
		);

	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty (
		"Address Filter",
		"Specify the address to monitor"
		);

	m_outOfOrderLimitProp = m_pluginHost.m_propertyGrid.createIntProperty (
		"Out-of-order Limit",
		"Specify the maximum number of out-of-order segments"
		);

	m_uiReactor.start ();
}

TcpFlowMonSession.onCapture ()
{
	if (m_state)
		stopCapture ();
	else
		try capture ();
}

TcpFlowMonSession.onSetFilter ()
{
	if (!m_state)
		try capture ();
	else
		try applyFilter ();	
}

bool TcpFlowMonSession.capture () throws
{
	stopCapture ();

	io.PCapDeviceDesc const* device = m_deviceCombo.m_currentData;
	if (!device)
		return false;

	char const* addressString = m_filterCombo.m_editText;
	m_filterCombo.addEditTextToHistory ();

	io.SocketAddress filterAddress;
	bool isDirectAddress = try filterAddress.parse (addressString);
	if (isDirectAddress)
		return try capture (&filterAddress);

	writeLogString (TcpFlowMonLogRecordCode.Resolving, addressString);

	m_resolver.m_syncId = m_pcap.m_syncId;
	bool result = try m_resolver.resolve (addressString);
	if (!result)
	{
		writeLogLastError (TcpFlowMonLogRecordCode.ResolveError);
		return false;
	}

	m_state = State.Resolving;
	return true;
}

bool TcpFlowMonSession.capture (io.SocketAddress const* filterAddress) throws
{
	stopCapture ();
		
	io.PCapDeviceDesc const* device = m_deviceCombo.m_currentData;
	if (!device)
		return false;
	
	char const* filterString = createFilterString (filterAddress);
	writeLogString (TcpFlowMonLogRecordCode.StartingCapture, filterString);
	
	bool result = try m_pcap.open (
		device.m_name, 
		filterString,
		m_promisciousProp.m_value
		);
		
	if (!result)
	{
		writeLogLastError (TcpFlowMonLogRecordCode.CaptureError);
		return false;
	}

	m_state = State.Capturing;
	m_filterAddress = *filterAddress;
	writeLog (TcpFlowMonLogRecordCode.CaptureStarted);
	return true;
}

TcpFlowMonSession.stopCapture ()
{
	if (!m_state)
		return;

	if (m_state & State.Resolving)
		writeLog (TcpFlowMonLogRecordCode.ResolveCancelled);		
	
	if (m_state & State.Capturing)
		writeLog (TcpFlowMonLogRecordCode.CaptureStopped);
	
	m_pcap.close ();
	m_state = 0;
}

bool TcpFlowMonSession.applyFilter () throws
{
	char const* filterString = m_filterCombo.m_editText;
	m_filterCombo.addEditTextToHistory ();

	io.SocketAddress filterAddress;
	bool isDirectAddress = try filterAddress.parse (filterString);
	if (isDirectAddress)
	{
		m_state &= ~State.Resolving;
		return try setFilter (&filterAddress);	
	}

	writeLogString (TcpFlowMonLogRecordCode.Resolving, filterString);
		
	m_resolver.m_syncId = m_pcap.m_syncId;
	bool result = try m_resolver.resolve (filterString);
	if (!result)
	{
		writeLogLastError (TcpFlowMonLogRecordCode.ResolveError);
		return false;
	}
	
	m_state |= State.Resolving;
	return true;
}

bool TcpFlowMonSession.setFilter (io.SocketAddress const* filterAddress) throws
{
	if (!m_state.Capturing)
		return true;

	char const* filterString = createFilterString (filterAddress);
	writeLogString (TcpFlowMonLogRecordCode.ChangingFilter, filterString);
	bool result = try m_pcap.setFilter (filterString);
	if (!result)
	{
		writeLogLastError (TcpFlowMonLogRecordCode.FilterError);
		return false;
	}
	
	writeLog (TcpFlowMonLogRecordCode.FilterChanged);
	return true;
}

char const* TcpFlowMonSession.createFilterString (io.SocketAddress const* filterAddress)
{
	char const* filterString = 
		filterAddress.m_family == io.AddressFamily.Ip6 ? $"tcp and host $(filterAddress.m_ip6.m_address.getString ())" :
		filterAddress.m_ip4.m_address.m_i32 ? $"tcp and host $(filterAddress.m_ip4.m_address.getString ())" :
		"tcp";

	if (filterAddress.m_ip4.m_port)
		filterString = $"$filterString and port $(filterAddress.m_ip4.m_port)";
	
	return filterString;
}

void TcpFlowMonSession.load (doc.Storage* storage)
{
	m_deviceCombo.m_currentIndex = storage.readInt ("device");
	m_promisciousProp.m_value = storage.readBool ("promiscious");
	m_filterCombo.m_editText = storage.readString ("captureFilter");
	m_outOfOrderLimitProp.m_value = storage.readInt ("outOfOrderLimit");
}

void TcpFlowMonSession.save (doc.Storage* storage)
{
	storage.writeInt ("device", (int) m_deviceCombo.m_currentIndex);
	storage.writeBool ("promiscious", m_promisciousProp.m_value);
	storage.writeString ("captureFilter", m_filterCombo.m_editText);
	storage.writeInt ("outOfOrderLimit", m_outOfOrderLimitProp.m_value);
}

void TcpFlowMonSession.updateProperties ()
{
	io.PCapDeviceDesc const* device = m_deviceCombo.m_currentData;
	if (!device)
		return;
	
	m_filterProp.m_value = m_filterCombo.m_editText;
	m_deviceProp.m_value = device.m_name;
}

bool TcpFlowMonSession.applyProperties () throws
{
	// m_deviceCombo.m_currentIndex = m_deviceProp.m_currentIndex;
	m_filterCombo.m_editText = m_filterProp.m_value;
	
	if (m_state.Capturing)
		applyFilter ();
	
	return true;
}

void TcpFlowMonSession.restoreDefaultProperties ()
{
	m_deviceProp.m_value = m_deviceCombo.m_itemText [0];
	m_promisciousProp.m_value = false;
	m_filterProp.m_value = "tibbo.com:80";
	m_outOfOrderLimitProp.m_value = 4;
}

TcpFlowMonSession.onResolverEvent (io.SocketAddressResolverEventParams const* params)
{
	if (params.m_syncId != m_pcap.m_syncId)
		return;

	m_state &= ~State.Resolving;

	switch (params.m_eventKind)
	{
	case io.SocketAddressResolverEvent.ResolveCompleted:
		writeLog (
			TcpFlowMonLogRecordCode.ResolveCompleted,
			params.m_addressTable,
			sizeof (io.SocketAddress)
			);

		if (m_state & State.Capturing)
			try setFilter (params.m_addressTable);
		else
			try capture (params.m_addressTable);
		break;

	case io.SocketAddressResolverEvent.ResolveError:
		writeLogError (TcpFlowMonLogRecordCode.ResolveError, params.m_error);
		break;
	}
}

TcpFlowMonSession.onReadyRead (uint_t syncId)
{
	if (syncId != m_pcap.m_syncId)
		return;

	static char buffer [1600]; // static is OK -- we read in main thread
	size_t result = try m_pcap.read (buffer, sizeof (buffer));
	if (result != -1)
		decodePacket (buffer, result);
}

bool TcpFlowMonSession.decodePacket (
	void const* p,
	size_t size
	)
{
	if (size < sizeof (io.EthernetHdr))
		return false;
	
	io.EthernetHdr const* ethernetHdr = (io.EthernetHdr const*) p;
	p += sizeof (io.EthernetHdr);
	size -= sizeof (io.EthernetHdr);

	io.SocketAddress srcAddress;
	io.SocketAddress dstAddress;

	switch (ethernetHdr.m_type)
	{
	case io.EthernetType.Ip:
		if (size < sizeof (io.IpHdr))
			return false;
		
		io.IpHdr const* ipHdr = (io.IpHdr const*) p;

		if (ipHdr.m_protocol != io.Protocol.Tcp ||
			ipHdr.m_totalLength > size)
			return false;
		
		srcAddress.m_family = io.AddressFamily.Ip4;
		srcAddress.m_ip4.m_address.m_i32 = ipHdr.m_srcAddress;
		dstAddress.m_family = io.AddressFamily.Ip4;
		dstAddress.m_ip4.m_address.m_i32 = ipHdr.m_dstAddress;		

		p += sizeof (io.IpHdr);
		size = ipHdr.m_totalLength - sizeof (io.IpHdr);
		break;

	case io.EthernetType.Ip6:
		if (size < sizeof (io.Ip6Hdr))
			return false;
		
		io.Ip6Hdr const* ip6Hdr = (io.Ip6Hdr const*) p;

		if (ip6Hdr.m_nextHeader != io.Protocol.Tcp ||
			ip6Hdr.m_payloadLength + sizeof (io.Ip6Hdr) > size)
			return false;
		
		srcAddress.m_family = io.AddressFamily.Ip6;
		srcAddress.m_ip6.m_address = *(io.Address_ip6 const*) ip6Hdr.m_srcAddress;
		dstAddress.m_family = io.AddressFamily.Ip6;
		dstAddress.m_ip6.m_address = *(io.Address_ip6 const*) ip6Hdr.m_dstAddress;		

		p += sizeof (io.Ip6Hdr);
		size = ip6Hdr.m_payloadLength;
		break;

	default:
		return false;
	}	

	io.TcpHdr const* tcpHdr = (io.TcpHdr const*) p;
	size_t tcpHdrSize = tcpHdr.m_dataOffset * 4;
	
	if (tcpHdrSize > size)
		return false;

	p += tcpHdrSize;
	size -= tcpHdrSize;

	srcAddress.m_ip4.m_port = tcpHdr.m_srcPort;
	dstAddress.m_ip4.m_port = tcpHdr.m_dstPort;

	if (!(m_state & State.TcpConnection))
	{
		if (!(tcpHdr.m_flags & io.TcpFlags.Syn) && !size)
			return false;

		size_t seqNumberDelta = (tcpHdr.m_flags & io.TcpFlags.Syn) ? 1 : 0;
		if (srcAddress.isMatch (&m_filterAddress))
		{
			m_tcpPeer1.m_address = srcAddress;
			m_tcpPeer1.m_seqNumber = tcpHdr.m_seqNumber + seqNumberDelta;
			m_tcpPeer1.m_outOfOrderSegment = null;
			m_tcpPeer1.m_outOfOrderSegmentCount = 0;
			
			m_tcpPeer2.m_address = dstAddress;
			m_tcpPeer2.m_seqNumber = tcpHdr.m_ackNumber;
			m_tcpPeer2.m_outOfOrderSegment = null;
			m_tcpPeer2.m_outOfOrderSegmentCount = 0;
		}
		else if (dstAddress.isMatch (&m_filterAddress))
		{
			m_tcpPeer1.m_address = dstAddress;
			m_tcpPeer1.m_seqNumber = tcpHdr.m_ackNumber;
			m_tcpPeer1.m_outOfOrderSegment = null;
			m_tcpPeer1.m_outOfOrderSegmentCount = 0;

			m_tcpPeer2.m_address = srcAddress;
			m_tcpPeer2.m_seqNumber = tcpHdr.m_seqNumber + seqNumberDelta;
			m_tcpPeer2.m_outOfOrderSegment = null;
			m_tcpPeer2.m_outOfOrderSegmentCount = 0;
		}
		else 
		{
			return false;
		}
		
		char const* params = $"$(srcAddress; B)$(dstAddress; B)";
		
		if (!(tcpHdr.m_flags & io.TcpFlags.Syn))
		{
			writeLog (
				TcpFlowMonLogRecordCode.ConnectionPickedUp,
				params,
				dynamic sizeof (*params)
				);
		}
		else if (!(tcpHdr.m_flags & io.TcpFlags.Ack))
		{
			writeLog (
				TcpFlowMonLogRecordCode.Connecting,
				params,
				dynamic sizeof (*params)
				);			
			
			m_state |= State.TcpSyn;
		}
		else // Syn + Ack
		{
			writeLog (
				TcpFlowMonLogRecordCode.Connecting,
				params,
				dynamic sizeof (*params)
				);			

			writeLog (TcpFlowMonLogRecordCode.ConnectCompleted);			
		}
		
		m_state |= State.TcpConnection;		
	}

	if (
		m_tcpPeer1.m_address.isEqual (&srcAddress) &&
		m_tcpPeer2.m_address.isEqual (&dstAddress))
	{
		decodeTcpPacket (&m_tcpPeer1, tcpHdr, p, size);
	}
	else if (
		m_tcpPeer2.m_address.isEqual (&srcAddress) &&
		m_tcpPeer1.m_address.isEqual (&dstAddress))
	{
		decodeTcpPacket (&m_tcpPeer2, tcpHdr, p, size);
	}
	else
	{
		return false;
	}

	return true;
}

TcpFlowMonSession.decodeTcpPacket (
	TcpFlowMonSession.TcpPeer* peer,
	io.TcpHdr const* tcpHdr,
	void const* p,
	size_t size
	)
{
	if ((tcpHdr.m_flags & io.TcpFlags.Rst) || 
		(tcpHdr.m_flags & io.TcpFlags.Fin))
	{
		writeLog (
			TcpFlowMonLogRecordCode.Disconnected,
			peer.m_address,
			sizeof (peer.m_address)
			);
		
		m_state &= ~(State.TcpConnection | State.TcpSyn);
	}
	else if (
		(tcpHdr.m_flags & io.TcpFlags.Syn) && 
		(tcpHdr.m_flags & io.TcpFlags.Ack) &&
		m_state & State.TcpSyn)
	{
		writeLog (TcpFlowMonLogRecordCode.ConnectCompleted);		
		peer.m_seqNumber = tcpHdr.m_seqNumber + 1;
		m_state &= ~State.TcpSyn;
	}
	else if (size)
	{	
		decodeTcpDataSegment (peer, tcpHdr.m_seqNumber, p, size);
	}
}

TcpFlowMonSession.writeTcpData (
	TcpFlowMonSession.TcpPeer* peer,
	uint32_t seqNumber,
	void const* p,
	size_t size
	)
{
	if ((intptr) (peer.m_seqNumber - seqNumber) > 0) // retransmission
	{
		size_t skip = peer.m_seqNumber - seqNumber;
		if (skip >= size)
			return;

		p += skip;
		size -= skip;
	}

	writeLog (peer.m_recordCode, p, size);
	peer.m_seqNumber = seqNumber + size;
}

TcpFlowMonSession.decodeTcpDataSegment (
	TcpFlowMonSession.TcpPeer* peer,
	uint32_t seqNumber,
	void const* p,
	size_t size
	)
{
	if ((intptr) (seqNumber - peer.m_seqNumber) > 0)
	{
		addTcpOutOfOrderSegment (peer, seqNumber, p, size);
	}
	else
	{
		writeTcpData (peer, seqNumber, p, size);
		writeAlignedTcpOutOfOrderSegments (peer);
	}
}

TcpFlowMonSession.addTcpOutOfOrderSegment (
	TcpFlowMonSession.TcpPeer* peer,
	uint32_t seqNumber,
	void const* p,
	size_t size
	)
{
	TcpOutOfOrderSegment* segment = new TcpOutOfOrderSegment;
	segment.m_seqNumber = seqNumber;
	segment.m_p = new char [size];
	segment.m_size = size;
	memcpy (segment.m_p, p, size);
	
	// find location to insert it
	
	TcpOutOfOrderSegment** loc = &peer.m_outOfOrderSegment;
	TcpOutOfOrderSegment* next = peer.m_outOfOrderSegment;	
	while (next)
	{
		if (seqNumber == next.m_seqNumber) // duplicate segment
			return;

		if (seqNumber < next.m_seqNumber)
			break;
		
		loc = &next.m_next;
		next = next.m_next;
	}
	
	segment.m_next = next;
	*loc = segment;
	peer.m_outOfOrderSegmentCount++;

	if (peer.m_outOfOrderSegmentCount < m_outOfOrderLimitProp.m_value)
		return;
	
	writeLog (TcpFlowMonLogRecordCode.OutOfOrderDataDropped);
	
	// maintain out-of-order limit

	while (
		peer.m_outOfOrderSegment &&
		peer.m_outOfOrderSegmentCount > m_outOfOrderLimitProp.m_value
		)
	{
		writeFirstTcpOutOfOrderSegment (peer);
	}	

	writeAlignedTcpOutOfOrderSegments (peer);
}

TcpFlowMonSession.writeFirstTcpOutOfOrderSegment (TcpFlowMonSession.TcpPeer* peer)
{
	writeTcpData (
		peer, 
		peer.m_outOfOrderSegment.m_seqNumber, 
		peer.m_outOfOrderSegment.m_p, 
		peer.m_outOfOrderSegment.m_size
		);
	
	peer.m_outOfOrderSegment = peer.m_outOfOrderSegment.m_next;
	peer.m_outOfOrderSegmentCount--;
}

TcpFlowMonSession.writeAlignedTcpOutOfOrderSegments (TcpFlowMonSession.TcpPeer* peer)
{
	while (
		peer.m_outOfOrderSegment &&
		peer.m_outOfOrderSegment.m_seqNumber <= peer.m_seqNumber
		)
	{
		writeFirstTcpOutOfOrderSegment (peer);
	}	
}

reactor TcpFlowMonSession.m_uiReactor ()
{
	m_title = $"TCP Mon $(m_filterCombo.m_currentText)";
	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
	m_statusPaneTable [StatusPaneId.State].m_text = 
		(m_state & State.Capturing) ? "Capturing" : 
		(m_state & State.Resolving) ? "Resolving" :
		"Closed";
}

//.............................................................................
