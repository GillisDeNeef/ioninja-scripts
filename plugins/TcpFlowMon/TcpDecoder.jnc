//..............................................................................
//
// TCP packet decoder
//

import "doc_PluginHost.jnc"
import "io_IpDefragmenter.jnc"
import "std_HashTable.jnc"

//..............................................................................

class TcpDecoder
{
	enum Defaults
	{
		ConnectionTimeout = 60000, // drop SynSent, FinWait or TimeWait connections
	}

protected:
	class TcpPeer
	{
		io.SocketAddress m_address;
		TcpSequencer m_sequencer;

		construct(doc.PluginHost* pluginHost)
		{
			m_sequencer.construct(pluginHost);
		}
	}

	// use a simplified TCP state machine for *both* peers (not the RFC 793 one)

	enum ConnectionState
	{
		SynSent,     // initial SYN has been seen
		SynReceived, // SYN | ACK has been seen
		Established, // 3-way handshake completed (or connection has been picked up)
		ClientFin,   // initial FIN has been seen from client
		ServerFin,   // initial FIN has been seen from server
		TimeWait,    // two FINs from both sides has been seen
	}

	struct ConnectionKey
	{
		io.SocketAddress m_srcAddress;
		io.SocketAddress m_dstAddress;
	}

	class Connection
	{
		std.ListEntry* m_listEntry;
		ConnectionState m_state;
		uint64_t m_logSyncId;
		uint64_t m_timestamp;
		TcpPeer m_clientPeer;
		TcpPeer m_serverPeer;

		construct(doc.PluginHost* pluginHost)
		{
			m_clientPeer.construct(pluginHost);
			m_serverPeer.construct(pluginHost);
		}
	}

protected:
	doc.PluginHost* m_pluginHost;
	log.Writer*	m_logWriter;
	io.IpDefragmenter m_ipDefragmenter;
	std.HashTable m_connectionMap;
	std.List m_connectionList;
	uint_t m_connectionTimeout;

public:
	size_t bindable readonly m_connectionCount;
	io.SocketAddress m_captureFilterAddress; // freely adjustible

public:
	construct(doc.PluginHost* pluginHost);

	void setup(
		size_t ipFramentLimit,
		uint_t ipFragmentTimeout,
		size_t outOfSeqLimit,
		uint_t connectionTimeout
		);

	void reset();

	bool decode(
		void const* p,
		size_t size
		);

protected:
	Connection* createConnection(
		io.SocketAddress const* srcAddress,
		io.SocketAddress const* dstAddress,
		io.TcpHdr const* tcpHdr
		);

	void removeConnection(Connection* connection);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

TcpDecoder.construct(doc.PluginHost* pluginHost)
{
	m_pluginHost = pluginHost;
	m_logWriter = pluginHost.m_log.m_writer;
	m_connectionTimeout = Defaults.ConnectionTimeout;
}

void TcpDecoder.setup(
	size_t ipFramentLimit,
	uint_t ipFragmentTimeout,
	size_t outOfSeqLimit,
	uint_t connectionTimeout
	)
{
	m_ipDefragmenter.m_fragmentLimit = ipFramentLimit;
	m_ipDefragmenter.m_timeout = ipFragmentTimeout;
	m_connectionTimeout = connectionTimeout;

	std.ListEntry* entry = m_connectionList.m_head;
	for (; entry; entry = entry.m_next)
	{
		Connection* connection = entry.m_data;
		connection.m_clientPeer.m_sequencer.m_outOfSeqLimit = outOfSeqLimit;
		connection.m_serverPeer.m_sequencer.m_outOfSeqLimit = outOfSeqLimit;
	}
}

void TcpDecoder.reset()
{
	m_ipDefragmenter.reset();
	m_connectionList.clear();
	m_connectionMap.clear();
}

bool TcpDecoder.decode(
	void const* p,
	size_t size
	)
{
	if (size < sizeof(io.EthernetHdr))
		return false;

	io.EthernetHdr const* ethernetHdr = (io.EthernetHdr const*) p;
	p += sizeof(io.EthernetHdr);
	size -= sizeof(io.EthernetHdr);

	io.SocketAddress srcAddress;
	io.SocketAddress dstAddress;

	switch (ethernetHdr.m_type)
	{
	case io.EthernetType.Ip:
		if (size < sizeof(io.IpHdr))
			return false;

		io.IpHdr const* ipHdr = (io.IpHdr const*) p;
		size_t ipHdrSize = ipHdr.m_headerLength * 4;

		if (ipHdr.m_protocol != io.Protocol.Tcp ||
			ipHdrSize < sizeof(io.IpHdr) ||
			ipHdrSize > ipHdr.m_totalLength ||
			ipHdr.m_totalLength > size)
			return false;

		if ((ipHdr.m_flags & io.IpFlags.Mf) || ipHdr.m_fragmentOffset) // fragmented ip
		{
			ipHdr = m_ipDefragmenter.defragment(ipHdr, size);
			if (!ipHdr)
				return false;

			p = ipHdr + 1;
			size = dynamic sizeof(p);
		}
		else
		{
			p += ipHdrSize;
			size = ipHdr.m_totalLength - ipHdrSize;
		}

		srcAddress.m_family = io.AddressFamily.Ip4;
		srcAddress.m_ip4.m_address.m_i32 = ipHdr.m_srcAddress;
		dstAddress.m_family = io.AddressFamily.Ip4;
		dstAddress.m_ip4.m_address.m_i32 = ipHdr.m_dstAddress;
		break;

	case io.EthernetType.Ip6:
		if (size < sizeof(io.Ip6Hdr))
			return false;

		io.Ip6Hdr const* ip6Hdr = (io.Ip6Hdr const*) p;

		if (ip6Hdr.m_nextHeader != io.Protocol.Tcp ||
			ip6Hdr.m_payloadLength + sizeof(io.Ip6Hdr) > size)
			return false;

		p += sizeof(io.Ip6Hdr);
		size = ip6Hdr.m_payloadLength;

		srcAddress.m_family = io.AddressFamily.Ip6;
		srcAddress.m_ip6.m_address = *(io.Address_ip6 const*) ip6Hdr.m_srcAddress;
		dstAddress.m_family = io.AddressFamily.Ip6;
		dstAddress.m_ip6.m_address = *(io.Address_ip6 const*) ip6Hdr.m_dstAddress;
		break;

	default:
		return false;
	}

	if (srcAddress.isEqual(dstAddress) || size < sizeof(io.TcpHdr)) // invalid packet
		return false;

	io.TcpHdr const* tcpHdr = (io.TcpHdr const*) p;
	size_t tcpHdrSize = tcpHdr.m_dataOffset * 4;
	if (tcpHdrSize < sizeof(io.TcpHdr) || tcpHdrSize > size) // invalid packet
		return false;

	p += tcpHdrSize;
	size -= tcpHdrSize;

	srcAddress.m_port = tcpHdr.m_srcPort;
	dstAddress.m_port = tcpHdr.m_dstPort;

	Connection* connection;
	TcpPeer* peer;
	ConnectionKey key = { srcAddress, dstAddress };
	std.MapEntry* entry = m_connectionMap.visit(key);
	if (entry.m_value)
	{
		connection = entry.m_value;
		if (connection.m_state == ConnectionState.TimeWait)
			return true; // discard

		peer = connection.m_clientPeer.m_address.isEqual(srcAddress) ?
			&connection.m_clientPeer :
			&connection.m_serverPeer;
	}
	else
	{
		if (!size && !(tcpHdr.m_flags & io.TcpFlags.Syn) || (tcpHdr.m_flags & io.TcpFlags.Fin))
			return false; // don't pick up empty segments

		if (m_captureFilterAddress.m_family &&
			!m_captureFilterAddress.isMatch(srcAddress) &&
			!m_captureFilterAddress.isMatch(dstAddress))
			return false; // didn't pass capture filter

		connection = createConnection(srcAddress, dstAddress, tcpHdr);
		m_connectionList.add(connection);

		// add to map (also, with the inversed key)

		entry.m_value = connection;
		key = { dstAddress, srcAddress };
		m_connectionMap[key] = connection;
	}

	// for now, handle graceful disconnect just by dropping connection

	if (tcpHdr.m_flags & (io.TcpFlags.Rst | io.TcpFlags.Fin))
	{
		m_logWriter.write(
			(tcpHdr.m_flags & io.TcpFlags.Rst) ?
				TcpFlowMonLogRecordCode.Reset :
				TcpFlowMonLogRecordCode.Disconnected,
			&dstAddress,
			sizeof(io.SocketAddress),
			&srcAddress,
			sizeof(io.SocketAddress)
			);

		removeConnection(connection);
		return true;
	}

	switch (connection.m_state)
	{
	case ConnectionState.SynSent:
		if (peer != connection.m_serverPeer ||
			!(tcpHdr.m_flags & io.TcpFlags.Syn) ||
			!(tcpHdr.m_flags & io.TcpFlags.Ack) ||
			tcpHdr.m_ackNumber != connection.m_clientPeer.m_sequencer.m_seqNumber)
			return false;

		connection.m_state = ConnectionState.SynReceived;
		connection.m_serverPeer.m_sequencer.m_seqNumber++; // syn pseudo-byte
		break;

	case ConnectionState.SynReceived:
		if (peer != connection.m_clientPeer ||
			!(tcpHdr.m_flags & io.TcpFlags.Ack) ||
			tcpHdr.m_ackNumber != connection.m_serverPeer.m_sequencer.m_seqNumber)
			return false;

		connection.m_state = ConnectionState.Established;
		m_logWriter.write(SocketLogRecordCode.ConnectCompleted);
		break;

	case ConnectionState.Established:
		break;

	case ConnectionState.ClientFin:
	case ConnectionState.ServerFin:
		// not yet
		break;
	}

	if (size)
		peer.m_sequencer.write(tcpHdr.m_seqNumber, p, size);

	connection.m_timestamp = sys.getTimestamp();
	m_connectionList.moveToHead(connection.m_listEntry);
	return true;
}

TcpDecoder.Connection* TcpDecoder.createConnection(
	io.SocketAddress const* srcAddress,
	io.SocketAddress const* dstAddress,
	io.TcpHdr const* tcpHdr
	)
{
	Connection* connection = new Connection(m_pluginHost);
	connection.m_clientPeer.m_sequencer.m_logRecordCode = log.StdRecordCode.Tx;
	connection.m_serverPeer.m_sequencer.m_logRecordCode = log.StdRecordCode.Rx;

	uint64_t recordCode;

	if (!(tcpHdr.m_flags & io.TcpFlags.Syn)) // picking up existing connection
	{
		connection.m_state = ConnectionState.Established;
		connection.m_clientPeer.m_address = *srcAddress;
		connection.m_clientPeer.m_sequencer.m_seqNumber = tcpHdr.m_seqNumber;
		connection.m_serverPeer.m_address = *dstAddress;
		connection.m_serverPeer.m_sequencer.m_seqNumber = tcpHdr.m_ackNumber;
		recordCode = TcpFlowMonLogRecordCode.ConnectionPickedUp;
	}
	else if (tcpHdr.m_flags & io.TcpFlags.Ack) // syn-ack from server
	{
		connection.m_state = ConnectionState.SynReceived;
		connection.m_clientPeer.m_address = *dstAddress;
		connection.m_clientPeer.m_sequencer.m_seqNumber = tcpHdr.m_ackNumber;
		connection.m_serverPeer.m_address = *srcAddress;
		connection.m_serverPeer.m_sequencer.m_seqNumber = tcpHdr.m_seqNumber + 1; // syn pseudo-byte
		recordCode = SocketLogRecordCode.ConnectingFrom;
	}
	else // initial syn from client
	{
		connection.m_state = ConnectionState.SynSent;
		connection.m_clientPeer.m_address = *srcAddress;
		connection.m_clientPeer.m_sequencer.m_seqNumber = tcpHdr.m_seqNumber + 1; // syn pseudo-byte
		connection.m_serverPeer.m_address = *dstAddress;
		connection.m_serverPeer.m_sequencer.m_seqNumber = tcpHdr.m_ackNumber;
		recordCode = SocketLogRecordCode.ConnectingFrom;
	}

	m_logWriter.write(
		recordCode,
		connection.m_clientPeer.m_address,
		sizeof(io.SocketAddress),
		connection.m_serverPeer.m_address,
		sizeof(io.SocketAddress)
		);

	if (connection.m_state != ConnectionState.Established)
	{
		connection.m_logSyncId = sys.getTimestamp();
		m_logWriter.sync(connection.m_logSyncId);
	}

	m_connectionList.add(connection);
	m_connectionCount = m_connectionList.m_count;
	return connection;
}

void TcpDecoder.removeConnection(TcpDecoder.Connection* connection)
{
	m_connectionList.remove(connection.m_listEntry);
	ConnectionKey key = { connection.m_clientPeer.m_address, connection.m_serverPeer.m_address };
	m_connectionMap.removeKey(key);
	key = { connection.m_serverPeer.m_address, connection.m_clientPeer.m_address };
	m_connectionMap.removeKey(key);
}

//..............................................................................
