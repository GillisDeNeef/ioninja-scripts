//..............................................................................
//
// Ethernet sniffer log representer
//

import "log_Representation.jnc"

//..............................................................................

bool representEthernetSnifferLog(
	log.Representation* representation,
	uint64_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	switch (recordCode)
	{
	case EthernetSnifferLogRecordCode.DeviceOpened:
		char const* name = (char const*)p;
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Info;
		representation.addHyperText($"Sniffer device \e[34m$name\e[m opened");
		break;

	case EthernetSnifferLogRecordCode.InterfaceClaimed:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Info;
		representation.addHyperText($"Interface \e[34m#0\e[m claimed");
		break;

	case EthernetSnifferLogRecordCode.InEndpointOpened:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Info;
		representation.addHyperText($"In endpoint \e[34m#86\e[m opened");
		break;

	case EthernetSnifferLogRecordCode.OutEndpointOpened:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Info;
		representation.addHyperText($"Out endpoint \e[34m#2\e[m opened");
		break;

	case EthernetSnifferLogRecordCode.CaptureStarted:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Connect;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Connect;
		representation.addHyperText($"Capture started");
		break;

	case EthernetSnifferLogRecordCode.CaptureStopped:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Disconnect;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Disconnect;
		representation.addHyperText("Capture stopped");
		break;

	case EthernetSnifferLogRecordCode.CaptureError:
		std.Error const* error = (std.Error const*)p;
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Error;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Error;
		representation.addHyperText($"Cannot open sniffer: $(error.m_description)");
		break;

	case EthernetSnifferLogRecordCode.Packet:
		uint32_t i = *(uint32_t const*)p;
		PacketHdr const* hdr = (PacketHdr const*)(p + sizeof(uint32_t));
		uint_t channel = (hdr.m_flags & PacketFlags.ChannelId) != 0;

		representation.m_lineAttr.m_backColor = ui.StdColor.PastelGray;
		representation.m_lineAttr.m_iconIdx = channel ?
			log.StdLogIcon.TxPacket :
			log.StdLogIcon.RxPacket;

		representation.addHyperText(
			$"[\e[34m$i\e[m] "
			$"channel: \e[34m$(channel + 1)\e[m "
			$"size: \e[34m$(hdr.m_size - sizeof(uint32_t))\e[m + CRC-32 "
			$"CRC: $((hdr.m_flags & PacketFlags.CrcValid) ? "\e[32mOK" : "\e[31mINVALID")\e[m"
			);

		if (channel)
		{
			representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Tx;
			representation.m_lineAttr.m_textColor = log.StdLogColor.Tx;
		}
		else
		{
			representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Rx;
			representation.m_lineAttr.m_textColor = log.StdLogColor.Rx;
		}

		representation.m_lineAttr.m_backColor = ui.ColorFlags.Transparent;
		representation.addBin(hdr + 1, hdr.m_size);
		break;

	case EthernetSnifferLogRecordCode.CypressBufferCleared:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		representation.m_lineAttr.m_backColor = log.StdLogColor.Info;
		representation.addHyperText($"Hardware buffer cleared");
		break;

	default:
		return false;
	}

	return true;
}

//..............................................................................
