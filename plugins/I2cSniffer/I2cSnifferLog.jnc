//..............................................................................
//
// I2C sniffer log packet declarations and representer
//

//..............................................................................

enum I2cSnifferLogRecordCode
{
	DeviceOpened = 0,
	InterfaceClaimed,
	InEndpointOpened,
	OutEndpointOpened,
	CaptureStarted,
	CaptureStopped,
	CaptureError,
	UnexpectedCode,
	I2cStart,
	I2cFinalizeStart7Bit,
	I2cFinalizeStart10Bit,
	I2cStop,
	I2cIncompleteTransaction,
	I2cIncompleteByte,
	I2cStopOutOfTransaction,
}

enum I2cSnifferLogPartCode
{
	I2cStartBegin = I2cSnifferLogRecordCode.I2cStart | log.PartCodeFlags.MergeableForward,
	I2cStartEnd = I2cSnifferLogRecordCode.I2cStart | log.PartCodeFlags.MergeableBackward,
}

//..............................................................................

bool representI2cSnifferLog (
	log.RepresenterTarget* target,
	uint_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	switch (recordCode)
	{
	case I2cSnifferLogRecordCode.DeviceOpened:
		char const* name = (char const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Sniffer device \e[34m$name\e[m opened");
		break;

	case I2cSnifferLogRecordCode.InterfaceClaimed:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Interface \e[34m#0\e[m claimed");
		break;

	case I2cSnifferLogRecordCode.InEndpointOpened:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"In endpoint \e[34m#86\e[m opened");
		break;

	case I2cSnifferLogRecordCode.OutEndpointOpened:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Out endpoint \e[34m#2\e[m opened");
		break;

	case I2cSnifferLogRecordCode.CaptureStarted:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Connect;
		target.m_lineAttr.m_backColor = log.StdLogColor.Connect;
		target.addHyperText ($"Capture started");
		break;

	case I2cSnifferLogRecordCode.CaptureStopped:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Disconnect;
		target.m_lineAttr.m_backColor = log.StdLogColor.Disconnect;
		target.addHyperText ("Capture stopped");
		break;

	case I2cSnifferLogRecordCode.CaptureError:
		std.Error const* error = (std.Error const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Error;
		target.m_lineAttr.m_backColor = log.StdLogColor.Error;
		target.addHyperText ($"Cannot open sniffer: $(error.m_description)");
		break;

	case I2cSnifferLogRecordCode.UnexpectedCode:
		uint_t code = ((uint_t const*) p) [0];
		uint_t state = ((uint_t const*) p) [1];
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Error;
		target.m_lineAttr.m_backColor = log.StdLogColor.Error;
		target.addHyperText ($"Unexpected code from sniffer (code: $code, decoder state: $state)");
		break;

	case I2cSnifferLogRecordCode.I2cStart:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText (I2cSnifferLogPartCode.I2cStartBegin, "I2C start");
		break;

	case I2cSnifferLogRecordCode.I2cFinalizeStart7Bit:
		uchar_t hdr = *(const uchar_t*) p;

		target.addHyperText (
			I2cSnifferLogPartCode.I2cStartEnd,
			$", %1 \e[34m@%(2; 02x)\e[m" (
				(hdr & 0x01) ? "read" : "write",
				hdr >> 1
				)
			);

		break;

	case I2cSnifferLogRecordCode.I2cFinalizeStart10Bit:
		uint16_t hdr = *(const uint16_t*) p;

		target.addHyperText (
			I2cSnifferLogPartCode.I2cStartEnd,
			$", %1 \e[34m@%(2; 03x)\e[m" (
				(hdr & 0x100) ? "read" : "write",
				(hdr & 0xff) | ((hdr & 0x60) >> 1)
				)
			);

		break;

	case I2cSnifferLogRecordCode.I2cStop:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ("I2C stop");
		break;

	case I2cSnifferLogRecordCode.I2cIncompleteTransaction:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText ("Incomplete transaction");
		break;

	case I2cSnifferLogRecordCode.I2cIncompleteByte:
		uint_t bitCount = *(uint_t const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText ($"Incomplete byte received ($(bitCount) bits)");
		break;

	case I2cSnifferLogRecordCode.I2cStopOutOfTransaction:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText ("I2C stop out-of-transaction");
		break;

	default:
		return false;
	}

	return true;
}

//..............................................................................

class I2cSnifferLogFilter: log.Filter
{
	volatile bool m_isStopVisible;

	construct ();

	override bool filter (
		uint64_t timestamp,
		uint_t recordCode,
		void const* p,
		size_t size
		);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

I2cSnifferLogFilter.construct ()
{
	m_isStopVisible = true;
}

bool I2cSnifferLogFilter.filter (
	uint64_t timestamp,
	uint_t recordCode,
	void const* p,
	size_t size
	)
{
	switch (recordCode)
	{
	case I2cSnifferLogRecordCode.I2cStop:
		return m_isStopVisible;

	default:
		return true; // everything else is visible
	}
}

//..............................................................................
