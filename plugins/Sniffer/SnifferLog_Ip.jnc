//.............................................................................
//
// Sniffer log IP packets handling 
//

//.............................................................................

char const* formatIpString (bigendian uint32_t ip32)
{
	uint8_t const* ip8 = (uint8_t const*) &ip32;
	return jnc.format (
		"%d.%d.%d.%d", 
		ip8 [0], ip8 [1], ip8 [2], ip8 [3]
		);
}

representIpHdr (
	log.RepresenterTarget* target,
	void const* p,
	size_t size,
	size_t baseOffset
	)
{
	io.IpHdr const* ipHdr = (io.IpHdr const*) (p + baseOffset);

	target.addHyperText (jnc.format (
		"\e[1mIP\n"
		"   \e[90mVERSION:  \e^!%d,%d\e[34m%d\n"
		"   \e[90mHLENGTH:  \e^!%d,%d\e[34m%d\n"
		"   \e[90mTOS:      \e^!%d,%d\e[34m%d\n"
		"   \e[90mTLENGTH:  \e^!%d,%d\e[34m%d\n"
		"   \e[90mID:       \e^!%d,%d\e[34m%d\n"
		"   \e[90mFLAGS:    \e^!%d,%d\e[34m%d\n"
		"   \e[90mTTL:      \e^!%d,%d\e[34m%d\n"
		"   \e[90mPROTO:    \e^!%d,%d\e[34m%d\n"
		"   \e[90mCHECKSUM: \e^!%d,%d\e[34m%04Xh\n"
		"   \e[90mSRC:      \e^!%d,%d\e[34m%s\n"
		"   \e[90mDST:      \e^!%d,%d\e[34m%s",
		
		baseOffset + offsetof (ipHdr.m_version), 
		sizeof (ipHdr.m_version), 
		ipHdr.m_version,

		baseOffset + offsetof (ipHdr.m_headerLength), 
		sizeof (ipHdr.m_headerLength), 
		ipHdr.m_headerLength * 4,

		baseOffset + offsetof (ipHdr.m_typeOfService), 
		sizeof (ipHdr.m_typeOfService), 
		ipHdr.m_typeOfService,

		baseOffset + offsetof (ipHdr.m_totalLength), 
		sizeof (ipHdr.m_totalLength), 
		ipHdr.m_totalLength,

		baseOffset + offsetof (ipHdr.m_identification), 
		sizeof (ipHdr.m_identification), 
		ipHdr.m_identification,

		baseOffset + offsetof (ipHdr.m_flags), 
		sizeof (ipHdr.m_flags), 
		ipHdr.m_flags,

		baseOffset + offsetof (ipHdr.m_timeToLive), 
		sizeof (ipHdr.m_timeToLive), 
		ipHdr.m_timeToLive,

		baseOffset + offsetof (ipHdr.m_protocol), 
		sizeof (ipHdr.m_protocol), 
		ipHdr.m_protocol,

		baseOffset + offsetof (ipHdr.m_headerChecksum), 
		sizeof (ipHdr.m_headerChecksum), 
		ipHdr.m_headerChecksum,

		baseOffset + offsetof (ipHdr.m_srcAddress), 
		sizeof (ipHdr.m_srcAddress), 
		formatIpString (ipHdr.m_srcAddress),

		baseOffset + offsetof (ipHdr.m_dstAddress), 
		sizeof (ipHdr.m_dstAddress), 
		formatIpString (ipHdr.m_dstAddress)
		));

	switch (ipHdr.m_protocol)
	{
	case io.IpProtocol.Icmp:
		representIcmpHdr (target, p, size, baseOffset + sizeof (io.IpHdr));
		break;

	case io.IpProtocol.Tcp:
		representTcpHdr (target, p, size, baseOffset + sizeof (io.IpHdr));
		break;

	case io.IpProtocol.Udp:
		representUdpHdr (target, p, size, baseOffset + sizeof (io.IpHdr));
		break;
	}
}

representIp(
	log.RepresenterTarget* target,
	void const* p,
	size_t size, 
	size_t baseOffset
	)
{
	if (baseOffset + sizeof (io.IpHdr) > size)
	{
		target.addHyperText (jnc.format ("[\e^+1\e[34m+\e[m] \e[1mIP\e[m [INVALID SIZE:%d]", size));
		return;
	}

	io.IpHdr const* ipHdr = (io.IpHdr const*) (p + baseOffset);
	
	switch (ipHdr.m_protocol)
	{
	case io.IpProtocol.Icmp:
		representIcmp (target, ipHdr, p, size, baseOffset + sizeof (io.IpHdr));
		break;

	case io.IpProtocol.Tcp:
		representTcp (target, ipHdr, p, size, baseOffset + sizeof (io.IpHdr));
		break;

	case io.IpProtocol.Udp:
		representUdp (target, ipHdr, p, size, baseOffset + sizeof (io.IpHdr));
		break;
		
	default:
		target.addHyperText (jnc.format (
			"[\e^+1\e[34m+\e[m] \e[1mIP \e[10;34m%s\e[m > \e[34m%s\e[m [PROTO:%d]",
			formatIpString (ipHdr.m_srcAddress), 
			formatIpString (ipHdr.m_dstAddress),
			ipHdr.m_protocol
			));

		size_t dataSize = ipHdr.m_totalLength - sizeof (io.IpHdr);
		representPacketData (target, p, size, baseOffset + sizeof (io.IpHdr), dataSize);
	}
}

//.............................................................................

