//..............................................................................
//
// Sniffer log representer
//

import "log_Representation.jnc"
import "io_TcpIp.jnc"
import "SnifferLogRecordCode.jnc"

//..............................................................................

enum SnifferLogHdrColor
{
	Ethernet   = ui.StdColor.Green,
	Arp        = ui.StdColor.Cyan,
	Ip         = ui.StdColor.Cyan,
	IpOptions  = ui.StdColor.Purple,
	Ip6        = ui.StdColor.Cyan,
	Tcp        = ui.StdColor.Blue,
	TcpOptions = ui.StdColor.Purple,
	Udp        = ui.StdColor.Blue,
	Icmp       = ui.StdColor.Blue,
}

//..............................................................................

bool representSnifferLog(
	log.Representation* representation,
	uint64_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	switch (recordCode)
	{
	case SnifferLogRecordCode.Packet:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;
		representPacket(representation, p, size, foldFlags);
		break;

	case SnifferLogRecordCode.InjectedPacket:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.TxPacket;
		representPacket(representation, p, size, foldFlags);
		break;

	case SnifferLogRecordCode.DefragmentedIp:
		representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;
		representDefragmentedIp(representation, p, size, foldFlags);
		break;

	default:
		return false;
	}

	return true;
}

//..............................................................................

representPacket(
	log.Representation* representation,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	// TODO: add data link switch, currently we support ethernet only

	representEthernet(representation, p, size, foldFlags);
}

representColorizedBin(
	log.Representation* representation,
	void const* p,
	size_t size,
	size_t const* hdrSizeTable,
	uint_t const* hdrColorTable,
	size_t hdrCount
	)
{
	representation.m_lineAttr.m_textColor = ui.StdColor.Gray;
	representation.m_lineAttr.m_backColor = ui.ColorFlags.Transparent;
	representation.addBin(p, size);

	ui.TextAttr attr;
	attr.m_backColor = ui.ColorFlags.Transparent;

	intptr_t retroOffset = -size;
	for (size_t i = 0; i < hdrCount; i++)
	{
		size_t size = hdrSizeTable[i];
		attr.m_textColor = hdrColorTable[i];
		representation.retroColorize(retroOffset, size, attr);
		retroOffset += size;
	}
}

representDefragmentedIp(
	log.Representation* representation,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	representation.m_lineAttr.m_backColor = ui.StdColor.PastelCyan;
	representation.addPlainText("Defragmented IP packet");

	if (foldFlags)
	{
		representation.addHyperText("[\e^-1\e[34m-\e[m]");

		size_t hdrSizeTable[8];
		uint_t hdrColorTable[8];

		size_t hdrCount = representIpHdr(representation, p, size, 0, hdrSizeTable, hdrColorTable, 0);
		representColorizedBin(representation, p, size, hdrSizeTable, hdrColorTable, hdrCount);
	}
	else
	{
		representIp(representation, p, size, 0);
	}
}

representPacketData(
	log.Representation* representation,
	void const* p,
	size_t size,
	size_t baseOffset,
	size_t length
	)
{
	if (baseOffset >= size)
		return;

	if (length == -1 || baseOffset + length >= size)
		length = size - baseOffset;

	representation.m_lineAttr.m_textColor = ui.StdColor.Gray;
	representation.m_lineAttr.m_backColor = ui.ColorFlags.Transparent;
	representation.addBin(p + baseOffset, length);
}

//..............................................................................
