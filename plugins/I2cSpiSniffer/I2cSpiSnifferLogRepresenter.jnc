//..............................................................................
//
// I2C sniffer log representer
//

import "log_Representer.jnc"

//..............................................................................

bool representI2cSpiSnifferLog(
	log.RepresenterTarget* target,
	uint64_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	switch (recordCode)
	{
	case I2cSpiSnifferLogRecordCode.DeviceOpened:
		char const* name = (char const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText($"Opened tap device \e[34m$name\e[m");
		break;

	case I2cSpiSnifferLogRecordCode.InterfaceClaimed:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText($"Interface \e[34m#0\e[m claimed");
		break;

	case I2cSpiSnifferLogRecordCode.InEndpointOpened:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText($"In endpoint \e[34m#86\e[m opened");
		break;

	case I2cSpiSnifferLogRecordCode.OutEndpointOpened:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText($"Out endpoint \e[34m#2\e[m opened");
		break;

	case I2cSpiSnifferLogRecordCode.CaptureStarted:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Connect;
		target.m_lineAttr.m_backColor = log.StdLogColor.Connect;
		target.addHyperText($"Capture started");
		break;

	case I2cSpiSnifferLogRecordCode.CaptureStopped:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Disconnect;
		target.m_lineAttr.m_backColor = log.StdLogColor.Disconnect;
		target.addHyperText("Capture stopped");
		break;

	case I2cSpiSnifferLogRecordCode.CaptureError:
		std.Error const* error = (std.Error const*)p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Error;
		target.m_lineAttr.m_backColor = log.StdLogColor.Error;
		target.addHyperText($"Cannot open sniffer: $(error.m_description)");
		break;

	case I2cSpiSnifferLogRecordCode.UnexpectedCode:
		uint_t code = ((uint_t const*)p)[0];
		uint_t state = ((uint_t const*)p)[1];
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Error;
		target.m_lineAttr.m_backColor = log.StdLogColor.Error;
		target.addHyperText($"Unexpected code from sniffer (code: $code, decoder state: $state)");
		break;

	case I2cSpiSnifferLogRecordCode.IncompleteByte:
		uint_t bitCount = *(uint_t const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText($"Incomplete byte received ($(bitCount) bit(s))");
		break;

	case I2cSpiSnifferLogRecordCode.FpgaBufferOverflow:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText("Hardware buffer overflow");
		break;

	case I2cSpiSnifferLogRecordCode.CypressBufferCleared:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText($"Hardware buffer cleared");
		break;

	case I2cSpiSnifferLogRecordCode.StillWaiting:
		target.m_lineAttr.m_backColor = gui.StdColor.PastelGray;
		target.addHyperText("...still waiting...");
		break;

	case I2cSpiSnifferLogRecordCode.FpgaDisabled:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("FPGA disabled");
		break;

	case I2cSpiSnifferLogRecordCode.FirmwareUpToDate:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("FPGA firmware is up-to-date");
		break;

	case I2cSpiSnifferLogRecordCode.FirmwareUpdateRequired:
		uint_t version = ((RpdVersion const*) p)->m_firmwareVersion;
		char const* fileName = (char const*) ((RpdVersion const*) p + 1);

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText(
			$"FPGA firmware update required: file \e[34m%1\e[m version \e[34m%2.%3\e[m" (
			fileName,
			(version >> 8) & 0xff,
			version & 0xff
			));
		break;

	case I2cSpiSnifferLogRecordCode.ErasingFlash:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("Erasing flash memory...");
		break;

	case I2cSpiSnifferLogRecordCode.UploadingFirmware:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("Uploading FPGA firmware...");
		break;

	case I2cSpiSnifferLogRecordCode.EnablingFpga:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("Enabling FPGA...");
		break;

	case I2cSpiSnifferLogRecordCode.FpgaReady:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("FPGA ready");
		break;

	case I2cSpiSnifferLogRecordCode.FirmwareUploadCancelled:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText("Uploading FPGA firmware cancelled");
		break;

	case I2cSpiSnifferLogRecordCode.FirmwareUploadCompleted:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("Uploading FPGA firmware completed");
		break;

	case I2cSpiSnifferLogRecordCode.I2cStart:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Play;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText(I2cSpiSnifferLogPartCode.I2cStartBegin, "I2C start");
		break;

	case I2cSpiSnifferLogRecordCode.I2cFinalizeStart7Bit:
		uint16_t hdr = *(const uint16_t*) p;
		bool isRead = hdr & 0x01;
		bool isAck = hdr & 0x0100;

		target.addHyperText(
			I2cSpiSnifferLogPartCode.I2cStartEnd,
			$"\x15I2C start (%1, I2C 7-bit address: \e[%2m0x%(3; 02x)\e[m)" (
				isRead ? "read" : "write",
				isAck ? "34" : "34;9",
				(hdr & 0xfe) >> 1
				)
			);

		target.m_lineAttr.m_iconIdx = isRead ? log.StdLogIcon.Rx : log.StdLogIcon.Tx;
		target.m_lineAttr.m_backColor = gui.ColorFlags.Transparent;
		target.m_lineAttr.m_textColor = gui.StdColor.Red;
		target.m_lineAttr.m_fontFlags = isAck ? 0 : gui.FontFlags.Strikeout;
		target.addBin(isRead ? log.StdRecordCode.Rx : log.StdRecordCode.Tx, p, 1);
		break;

	case I2cSpiSnifferLogRecordCode.I2cFinalizeStart10Bit:
		uint32_t hdr = *(const uint32_t*) p;
		bool isRead = hdr & 0x01;
		bool isAck1 = hdr & 0x00010000;
		bool isAck2 = hdr & 0x00020000;

		target.addHyperText(
			I2cSpiSnifferLogPartCode.I2cStartEnd,
			$"\x15I2C start (%1, I2C 10-bit address: \e[%2m0x%(3; 03x)\e[m)" (
				isRead ? "read" : "write",
				isAck1 && isAck2 ? "34" : "34;9",
				((hdr & 0x06) << 7) | ((hdr & 0xff00) >> 8)
				)
			);

		target.m_lineAttr.m_iconIdx = isRead ? log.StdLogIcon.Rx : log.StdLogIcon.Tx;
		target.m_lineAttr.m_backColor = gui.ColorFlags.Transparent;
		target.m_lineAttr.m_textColor = gui.StdColor.Red;

		uint64_t binRecordCode = isRead ? log.StdRecordCode.Rx : log.StdRecordCode.Tx;
		gui.FontFlags fontFlags1 = isAck1 ? 0 : gui.FontFlags.Strikeout;
		gui.FontFlags fontFlags2 = isAck2 ? 0 : gui.FontFlags.Strikeout;

		if (fontFlags1 == fontFlags2)
		{
			target.m_lineAttr.m_fontFlags = fontFlags1;
			target.addBin(binRecordCode, p, 2);
		}
		else
		{
			target.m_lineAttr.m_fontFlags = fontFlags1;
			target.addBin(binRecordCode, p, 1);
			target.m_lineAttr.m_fontFlags = fontFlags2;
			target.addBin(binRecordCode, p + 1, 1);
		}

		break;

	case I2cSpiSnifferLogRecordCode.I2cStop:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Stop;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("I2C stop");
		break;

	case I2cSpiSnifferLogRecordCode.I2cStopOutOfTransaction:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.m_lineAttr.m_backColor = log.StdLogColor.Warning;
		target.addHyperText("I2C \e[31mstop\e[m out-of-transaction");
		break;

	case I2cSpiSnifferLogRecordCode.I2cTxNack:
		target.m_lineAttr.m_flags = log.LineAttrFlags.TileIcon;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Tx;
		target.m_lineAttr.m_textColor = log.StdLogColor.Tx;
		target.m_lineAttr.m_fontFlags = gui.FontFlags.Strikeout;
		target.addBin(log.StdRecordCode.Tx, p, size);
		break;

	case I2cSpiSnifferLogRecordCode.I2cRxNack:
		target.m_lineAttr.m_flags = log.LineAttrFlags.TileIcon;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Rx;
		target.m_lineAttr.m_textColor = log.StdLogColor.Rx;
		target.m_lineAttr.m_fontFlags = gui.FontFlags.Strikeout;
		target.addBin(log.StdRecordCode.Rx, p, size);
		break;

	case I2cSpiSnifferLogRecordCode.SpiStart:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Play;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("SPI SS \e[32mlow\e[m");
		break;

	case I2cSpiSnifferLogRecordCode.SpiStop:
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Stop;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText("SPI SS \e[31mhigh\e[m");
		break;

	default:
		return false;
	}

	return true;
}

//..............................................................................
