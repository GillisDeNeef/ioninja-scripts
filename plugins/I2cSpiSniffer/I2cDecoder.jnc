//..............................................................................
//
// I2C protocol decoder
//

import "Decoder.jnc"

//..............................................................................

class I2cDecoder: Decoder
{
protected:
	enum Code
	{
		Padding         = 0xff,
		BufferOverflow  = 0xaa,
		Start           = 0,
		StartDataHi,    // 1
		DataHi,         // 2
		DataLoAck,      // 3
		DataLoNack,     // 4
		DataLoAckStop,  // 5
		DataLoNackStop, // 6
		Stop,           // 7
	}

	enum State
	{
		Idle,
		Transaction,
		DataHi,
	}

protected:
	State m_state;
	uint_t m_transactionDataRecordCode;
	size_t m_transactionSize;
	uchar_t m_firstTransactionByte;
	uchar_t m_dataHi;

public:
	construct (log.Writer* logWriter)
	{
		basetype.construct (logWriter);
	}

	override reset ()
	{
		m_state = State.Idle;
	}

	override decode (
		void const thin* p,
		size_t size
		);

protected:
	retroColorizeNack ();

	processDataLo (
		uint64_t timestamp,
		uchar_t dataLo,
		bool ack
		);

	static bool isAddress10Bit (uchar_t c)
	{
		return (c & 0xf8) == 0xf0;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

I2cDecoder.decode (
	void const thin* p0,
	size_t size
	)
{
	uint64_t timestamp = sys.getTimestamp ();
	uchar_t const thin* p = p0;
	uchar_t const thin* end = p + size;

	for (; p < end; p++)
	{
		uchar_t c = *p;

		switch (c)
		{
		case Code.Padding:
			continue;

		case Code.BufferOverflow:
			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.BufferOverflow);
			continue;
		}

		uchar_t code = (c & 0xf0) >> 4;
		switch (code)
		{
		case Code.Start:
			uint_t bitCount = c & 0x0f;

			if (bitCount)
				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, &bitCount, sizeof (bitCount));

			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStart);
			m_transactionSize = 0;
			m_state = State.Transaction;
			break;

		case Code.StartDataHi:
			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStart);
			m_dataHi = c << 4;
			m_state = State.DataHi;
			m_transactionSize = 0;
			break;

		case Code.DataHi:
			if (m_state != State.Transaction)
				writeLogUnexpectedCode (timestamp, code, m_state);

			m_dataHi = c << 4;
			m_state = State.DataHi;
			break;

		case Code.DataLoAck:
		case Code.DataLoNack:
			if (m_state != State.DataHi)
				writeLogUnexpectedCode (timestamp, code, m_state);

			processDataLo (timestamp, c & 0x0f, code == Code.DataLoAck);
			break;

		case Code.DataLoAckStop:
		case Code.DataLoNackStop:
			if (m_state != State.DataHi)
				writeLogUnexpectedCode (timestamp, code, m_state);

			processDataLo (timestamp, c & 0x0f, code == Code.DataLoAckStop);
			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStop);
			m_state = State.Idle;
			break;

		case Code.Stop:
			uint_t bitCount = c & 0x0f;
			if (m_state == State.DataHi)
				bitCount += 4;

			if (bitCount)
			{
				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, &bitCount, sizeof (bitCount));
				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStop);
			}
			else
			{
				m_logWriter.write (
					timestamp,
					m_state == State.Transaction ?
						I2cSpiSnifferLogRecordCode.I2cStop :
						I2cSpiSnifferLogRecordCode.I2cStopOutOfTransaction
					);
			}

			m_state = State.Idle;
			break;
		}
	}
}

I2cDecoder.retroColorizeNack ()
{
	gui.TextAttr attr;
	attr.m_textColor = gui.ColorFlags.Transparent;
	attr.m_backColor = gui.ColorFlags.Transparent;
	attr.m_fontFlags = gui.FontFlags.Strikeout;

	m_logWriter.retroColorize (-1, 1, attr);
}

I2cDecoder.processDataLo (
	uint64_t timestamp,
	uchar_t dataLo,
	bool ack
	)
{
	uchar_t data = dataLo | m_dataHi;

	if (m_transactionSize == 0) // process first byte
	{
		m_firstTransactionByte = data;
		m_transactionDataRecordCode = (data & 1) ? log.StdRecordCode.Rx : log.StdRecordCode.Tx;

		if (!isAddress10Bit (data))
			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cFinalizeStart7Bit, &data, sizeof (data));
	}
	else if (m_transactionSize == 1 && isAddress10Bit (m_firstTransactionByte)) // 10-bit addressing
	{
		uint16_t hdr = data | (m_firstTransactionByte << 8);
		m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cFinalizeStart10Bit, &hdr, sizeof (hdr));
	}
	else
	{
		m_logWriter.write (timestamp, m_transactionDataRecordCode, &data, sizeof (data));

		if (!ack)
			retroColorizeNack ();
	}

	m_transactionSize++;
	m_state = State.Transaction;
}

//..............................................................................

