//..............................................................................
//
// Modbus Protocol Analyzer log record declarations and representer
//

import "log.jnc"
import "io_Modbus.jnc"

//..............................................................................

representModbusCoils (
	log.RepresenterTarget* target,
	uint8_t const* p,
	size_t count,
	size_t baseOffset,
	uint_t foldFlags
	)
{
	switch (count)
	{
	case 0:
		target.addHyperText ("Value:     [\e[31mNONE\e[m]");
		break;

	case 1:
		target.addHyperText (
			$"Value:     \e^!-%1,%2\e[34m%3\e[m" (
			baseOffset,
			sizeof (uint8_t),
			*p & 1
			));
		break;

	case 2:
	case 3:
	case 4:
		target.addHyperText ($"Values [$count]");
		representModbusCoilValues (target, p, count, baseOffset);
		break;

	default:
		if (foldFlags)
		{
			target.addHyperText ($"[\e^-1\e[34m-\e[m] Values [$count]");
			representModbusCoilValues (target, p, count, baseOffset);
		}
		else
		{
			target.addHyperText ($"[\e^+1\e[34m+\e[m] Values [$count]");
		}
	}
}

representModbusCoilValues (
	log.RepresenterTarget* target,
	uint8_t const* p,
	size_t count,
	size_t baseOffset
	)
{
	size_t size = count / 8;
	if (count & 7)
		size++;

	size_t i = 0;
	for (size_t j = 0; i < count && j < size; j++)
	{
		uint8_t c = p [j];

		for (uint8_t mask = 1; i < count && mask; i++, mask <<= 1)
		{
			bool value = (c & mask) != 0;
			target.addHyperText (
				$"    #%(1; -3d): \e^!-%2,%3\e[34m%4\e[m" (
				i,
				baseOffset + j,
				sizeof (uint8_t),
				value
				));
		}
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

representModbusRegisters (
	log.RepresenterTarget* target,
	bigendian uint16_t const* p,
	size_t count,
	size_t baseOffset,
	uint_t foldFlags
	)
{
	switch (count)
	{
	case 0:
		target.addHyperText ("Value:     [\e[31mNONE\e[m]");
		break;

	case 1:
		target.addHyperText (
			$"Value:     \e^!-%1,%2\e[34m0x%(3; 04X)/%3\e[m" (
			baseOffset,
			sizeof (uint16_t),
			p [0]
			));
		break;

	case 2:
	case 3:
	case 4:
		target.addHyperText ($"Values [$count]");
		representModbusRegisterValues (target, p, count, baseOffset);
		break;

	default:
		if (foldFlags)
		{
			target.addHyperText ($"[\e^-1\e[34m-\e[m] Values [$count]");
			representModbusRegisterValues (target, p, count, baseOffset);
		}
		else
		{
			target.addHyperText ($"[\e^+1\e[34m+\e[m] Values [$count]");
		}
	}
}

representModbusRegisterValues (
	log.RepresenterTarget* target,
	bigendian uint16_t const* p,
	size_t count,
	size_t baseOffset
	)
{
	for (size_t i = 0; i < count; i++)
		target.addHyperText (
			$"    #%(1; -3d): \e^!-%2,%3\e[34m0x%(4; 04X)/%4\e[m" (
			i,
			baseOffset + i * sizeof (uint16_t),
			sizeof (uint16_t),
			p [i]
			));
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

representModbusPdu (
	log.RepresenterTarget* target,
	io.ModbusRole role,
	io.ModbusPduHdr const* hdr,
	size_t size,
	size_t baseOffset,
	uint_t foldFlags
	)
{
	target.addHyperText (
		$"Function:  \e^!-%1,%2\e[34m0x%(3; 02X)/%3\e[m - %4" (
		baseOffset + offsetof (hdr.m_func),
		sizeof (hdr.m_func),
		hdr.m_func,
		io.getModbusFuncString (hdr.m_func)
		));

	switch (hdr.m_func)
	{
	case io.ModbusFunc.ReadCoils:
	case io.ModbusFunc.ReadDiscreteInputs:
	case io.ModbusFunc.ReadHoldingRegisters:
	case io.ModbusFunc.ReadInputRegisters:
		if (role == io.ModbusRole.Master)
		{
			io.ModbusReadPdu const* pdu = (io.ModbusReadPdu const*) hdr;
			target.addHyperText (
				$"Address:   \e^!-%1,%2\e[34m0x%(3; 04X)/%3\e[m\n"
				$"Count:     \e^!-%4,%5\e[34m%6\e[m" (

				baseOffset + offsetof (pdu.m_address),
				sizeof (pdu.m_address),
				pdu.m_address,

				baseOffset + offsetof (pdu.m_count),
				sizeof (pdu.m_count),
				pdu.m_count
				));
		}
		else
		{
			io.ModbusReadReplyPdu const* pdu = (io.ModbusReadReplyPdu const*) hdr;

			if (hdr.m_func <= io.ModbusFunc.ReadDiscreteInputs)
			{
				target.addHyperText (
					$"Size:      \e^!-%1,%2\e[34m%3\e[m" (
					baseOffset + offsetof (pdu.m_size),
					sizeof (pdu.m_size),
					pdu.m_size
					));

				representModbusCoils (
					target,
					(uint8_t const*) (pdu + 1),
					pdu.m_size * 8,
					baseOffset + sizeof (io.ModbusReadReplyPdu),
					foldFlags
					);
			}
			else
			{
				target.addHyperText (
					$"Size:      \e^!-%1,%2\e[34m%3\e[m%4" (
					baseOffset + offsetof (pdu.m_size),
					sizeof (pdu.m_size),
					pdu.m_size,
					(pdu.m_size & 1) ? " [\e[31mINVALID\e[m] \e[90m(expected: a multiple of 2)" : ""
					));

				representModbusRegisters (
					target, (bigendian uint16_t const*) (pdu + 1),
					pdu.m_size / 2,
					baseOffset + sizeof (io.ModbusReadReplyPdu),
					foldFlags
					);
			}
		}
		break;

	case io.ModbusFunc.WriteCoil:
	case io.ModbusFunc.WriteRegister:
		io.ModbusWritePdu const* pdu = (io.ModbusWritePdu const*) hdr;
		target.addHyperText (
			$"Address:   \e^!-%1,%2\e[34m0x%(3; 04X)/%3\e[m\n"
			$"Value:     \e^!-%4,%5\e[34m0x%(6; 04X)/%6\e[m" (

			baseOffset + offsetof (pdu.m_address),
			sizeof (pdu.m_address),
			pdu.m_address,

			baseOffset + offsetof (pdu.m_value),
			sizeof (pdu.m_value),
			pdu.m_value
			));
		break;

	case io.ModbusFunc.WriteMultipleCoils:
	case io.ModbusFunc.WriteMultipleRegisters:
		if (role == io.ModbusRole.Master)
		{
			io.ModbusWriteMultiplePdu const* pdu = (io.ModbusWriteMultiplePdu const*) hdr;
			target.addHyperText (
				$"Address:   \e^!-%1,%2\e[34m0x%(3; 04X)/%3\e[m\n"
				$"Count:     \e^!-%4,%5\e[34m%6\e[m\n"
				$"Size:      \e^!-%7,%8\e[34m%9\e[m" (

				baseOffset + offsetof (pdu.m_address),
				sizeof (pdu.m_address),
				pdu.m_address,

				baseOffset + offsetof (pdu.m_count),
				sizeof (pdu.m_count),
				pdu.m_count,

				baseOffset + offsetof (pdu.m_size),
				sizeof (pdu.m_size),
				pdu.m_size
				));

			if (hdr.m_func == io.ModbusFunc.WriteMultipleCoils)
				representModbusCoils (
					target,
					(uint8_t const*) (pdu + 1),
					pdu.m_count,
					baseOffset + sizeof (io.ModbusWriteMultiplePdu),
					foldFlags
					);
			else
				representModbusRegisters (
					target,
					(bigendian uint16_t const*) (pdu + 1),
					pdu.m_count,
					baseOffset + sizeof (io.ModbusWriteMultiplePdu),
					foldFlags
					);
		}
		else
		{
			io.ModbusWriteMultipleReplyPdu const* pdu = (io.ModbusWriteMultipleReplyPdu const*) hdr;
			target.addHyperText (
				$"Address:   \e^!-%1,%2\e[34m0x%(3; 04X)/%3\n"
				$"Count:     \e^!-%4,%5\e[34m%6" (

				baseOffset + offsetof (pdu.m_address),
				sizeof (pdu.m_address),
				pdu.m_address,

				baseOffset + offsetof (pdu.m_count),
				sizeof (pdu.m_count),
				pdu.m_count
				));
		}
		break;

	case io.ModbusFunc.ReadExceptionStatus:
	case io.ModbusFunc.Diagnostics:
	case io.ModbusFunc.GetCommEventCounter:
	case io.ModbusFunc.GetCommEventLog:
	case io.ModbusFunc.ReportServerId:
	case io.ModbusFunc.ReadFileRecord:
	case io.ModbusFunc.WriteFileRecord:
	case io.ModbusFunc.MaskWriteRegister:
	case io.ModbusFunc.ReadWriteMultipleRegisters:
	case io.ModbusFunc.ReadFifoQueue:
	case io.ModbusFunc.EncapsulatedInterface:
		break; // not supported yet

	default:
		if (hdr.m_func & io.ModbusFunc.ExceptionFlag)
		{
			io.ModbusExceptionPdu const* pdu = (io.ModbusExceptionPdu const*) hdr;

			target.addHyperText (
				$"Exception: \e^!-%1,%2\e[31m0x%(3; 02X)/%3\e[m - %4" (
				baseOffset + offsetof (pdu.m_exceptionCode),
				sizeof (pdu.m_exceptionCode),
				pdu.m_exceptionCode,
				io.getModbusFuncString (pdu.m_exceptionCode)
				));
		}
	}
}

//..............................................................................
