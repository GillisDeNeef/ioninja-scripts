//..............................................................................
//
// Modbus Protocol Analyzer log record declarations and representer
//

import "log.jnc"
import "io_Modbus.jnc"

//..............................................................................

enum ModbusRtuLogRecordCode
{
	// need to avoid conflicts with SerialLog and SerialMonLog
	MasterPacket    = 0x200 | log.RecordCodeFlags.Foldable,
	SlavePacket     = 0x201 | log.RecordCodeFlags.Foldable,
	InvalidFunction = 0x204,
}

//..............................................................................

bool representModbusRtuLog (
	log.RepresenterTarget* target,
	uint_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	io.ModbusRole role;

	switch (recordCode)
	{
	case ModbusRtuLogRecordCode.MasterPacket:
		role = io.ModbusRole.Master;
		break;

	case ModbusRtuLogRecordCode.SlavePacket:
		role = io.ModbusRole.Slave;
		break;

	case ModbusRtuLogRecordCode.InvalidFunction:
		uint8_t code = *(uint8_t const*) p;
		target.m_lineAttr.m_backColor = gui.StdColor.PastelYellow;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Warning;
		target.addHyperText ($"Invalid or unsupported function: \e[31m0x%(1; 02X)/%1\e[m" (code));
		return true;

	default:
		return false;
	}

	io.ModbusRtuAduHdr const* aduHdr = (io.ModbusRtuAduHdr const*) p;
	io.ModbusPduHdr const* pduHdr = (io.ModbusPduHdr const*) (aduHdr + 1);

	target.m_lineAttr.m_backColor = gui.StdColor.PastelGray;
	target.m_lineAttr.m_iconIdx = role == io.ModbusRole.Master ?
		log.StdLogIcon.TxPacket :
		log.StdLogIcon.RxPacket;

	target.addHyperText (
		$"Address:   \e^!-%1,%2\e[34m0x%(3; 02X)/%3\e[m" (
		offsetof (aduHdr.m_deviceAddress),
		sizeof (aduHdr.m_deviceAddress),
		aduHdr.m_deviceAddress
		));

	size_t checksumOffset = size - sizeof (uint16_t);
	uint16_t actualChecksum = *(uint16_t const*) (p + checksumOffset);
	uint16_t expectedChecksum = crc16_ansi (p, checksumOffset, 0xffff);

	if (actualChecksum == expectedChecksum)
	{
		target.addHyperText (
			$"Checksum:  \e^!-%1,%2\e[34m0x%(3; 04X)/%3\e[m [\e[32mOK\e[m]" (
			checksumOffset,
			sizeof (uint16_t),
			actualChecksum
			));
	}
	else
	{
		target.addHyperText (
			$"Checksum:  \e^!-%1,%2\e[34m0x%(3; 04X)/%3\e[m [\e[31mERROR\e[m] \e[90m(expected: 0x%(4; 04X)/%4)\e[m" (
			checksumOffset,
			sizeof (uint16_t),
			actualChecksum,
			expectedChecksum
			));
	}

	representModbusPdu (
		target,
		role,
		pduHdr,
		size - sizeof (io.ModbusRtuAduHdr),
		sizeof (io.ModbusRtuAduHdr),
		foldFlags
		);

	return true;
}

//..............................................................................
