//..............................................................................
//
// OSDP stream parser base class
//

import "std_Buffer.jnc"
import "crc16.jnc"

//..............................................................................

class OsdpParser
{
protected:
	enum ParserState
	{
		Idle,
		Hdr,
		Packet,
	}

	ParserState m_parserState;
	std.Buffer m_packet;
        
        bool m_reply_received;
        char m_last_address;

public:
        bool m_filter_plain;
        bool m_filter_poll;
        
	void parse(
		log.Writer* writer,
		uint64_t timestamp,
		uint64_t originalRecordCode,
		char const* p,
		size_t size
		);

	void reset();

protected:
	void flush(
		log.Writer* writer,
		uint64_t timestamp,
		uint64_t originalRecordCode,
		char const* thin* base,
		char const* p
		);
                
                
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void OsdpParser.parse(
	log.Writer* writer,
	uint64_t timestamp,
	uint64_t originalRecordCode,
	char const* p,
	size_t size
	)
{
	char const* base = p;
	char const* end = p + size;

	while (p < end)
	{
		switch (m_parserState)
		{
		case ParserState.Idle:
			p = memchr(p, OsdpChar.Som, end - p);
			if (!p)
				break2; // out of the while loop

			m_parserState = ParserState.Hdr;
			m_packet.clear();

			// and fall through

		case ParserState.Hdr:
			size_t leftover = sizeof(OsdpHdr) - m_packet.m_size;
                        if (end - p < leftover)
			{
				m_packet.append(p, end - p);
				break2; // out of the while loop
			}

			m_packet.append(p, leftover);
			p += leftover;

			OsdpHdr const* hdr = (OsdpHdr const*)m_packet.m_p;
			if (hdr.m_length < sizeof(OsdpHdr)) // invalid length
			{
				if (!m_filter_plain) 
                                        flush(writer, timestamp, originalRecordCode, &base, p);
				writer.write(timestamp, OsdpLogRecordCode.InvalidPacketLength);
				m_parserState = ParserState.Idle;
				break;
			}

			m_parserState = ParserState.Packet;

			// and fall through

		case ParserState.Packet:
			OsdpHdr const* hdr = (OsdpHdr const*)m_packet.m_p;
			size_t leftover = hdr.m_length - m_packet.m_size;
			if (end - p < leftover)
			{
				m_packet.append(p, end - p);
				break2; // out of the while loop
			}
                        
			m_packet.append(p, leftover);
			p += leftover;
                        
			if (!m_filter_plain) 
                                flush(writer, timestamp, originalRecordCode, &base, p);
                                            
                        if (m_packet.m_p[1] & 0x80)
                        {
                                m_reply_received = true;
                        }
                        else if (!(m_packet.m_p[1] & 0x80) && m_reply_received)
                        {
                                m_reply_received = false;
                        }
                        else if (!(m_packet.m_p[1] & 0x80) && !m_reply_received)
                        {
                                writer.write(timestamp, OsdpLogRecordCode.Timeout, &m_last_address, 1);
                        }   
                        if (!(m_packet.m_p[1] & 0x80))
                        {
                                m_last_address = m_packet.m_p[1] & 0x7F;
                        }
                             
                        uint16_t crc = (m_packet.m_p[m_packet.m_size-2] & 0x00FF) + ((m_packet.m_p[m_packet.m_size-1] << 8)&0xFF00);
                        if (crc != crc16_ccitt(m_packet.m_p, m_packet.m_size - 2, 0x1D0F))
                        {
                                writer.write(timestamp, OsdpLogRecordCode.InvalidPacketCrc, m_packet.m_p, m_packet.m_size);
                                m_parserState = ParserState.Idle;
                                break;
                        }
                        
                        uint8_t scb_len = 0;
                        if (m_packet[4] & 0x08)
                                scb_len = m_packet[5];
                        
                        if (!m_filter_poll)
                                writer.write(timestamp, OsdpLogRecordCode.Packet, m_packet.m_p, m_packet.m_size);
                        else if (m_packet.m_p[5+scb_len] != OsdpCmdReplyCode.osdp_POLL && m_packet.m_p[5+scb_len] != OsdpCmdReplyCode.osdp_ACK)
                                writer.write(timestamp, OsdpLogRecordCode.Packet, m_packet.m_p, m_packet.m_size);
                        
			m_parserState = ParserState.Idle;
			break;
		}
	}

	if (!m_filter_plain) 
                flush(writer, timestamp, originalRecordCode, &base, end);
}

void OsdpParser.reset()
{
	m_parserState = ParserState.Idle;
	m_packet.clear();
        m_reply_received = true;
        m_last_address = 0;
}

void OsdpParser.flush(
	log.Writer* writer,
	uint64_t timestamp,
	uint64_t originalRecordCode,
	char const* thin* base,
	char const* p
	)
{
	char const* p0 = *base;
	if (p != p0)
	{
		writer.write(timestamp, originalRecordCode, p0, p - p0);
		*base = p;
	}
}

//..............................................................................
