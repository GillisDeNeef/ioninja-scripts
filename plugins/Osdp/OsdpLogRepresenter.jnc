//..............................................................................
//
// OSDP RTU log record declarations and representer
//

import "crc16.jnc"
import "log_Representation.jnc"
import "log_RepresentStruct.jnc"

//..............................................................................

bool representOsdpLog(
	log.Representation* representation,
	uint64_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	switch (recordCode)
	{
                case OsdpLogRecordCode.Packet:
                        representPacket(representation, p, size, foldFlags);
                        break;
                        
                case OsdpLogRecordCode.Timeout:
                        representTimeout(representation, p, size, foldFlags);
                        break;
                        
                case OsdpLogRecordCode.InvalidPacketCrc:
                        representInvalidCrc(representation, p, size, foldFlags);
                        break;

                case OsdpLogRecordCode.InvalidPacketLength:
                        representation.m_lineAttr.m_backColor = ui.StdColor.PastelRed;
                        representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;
                        representation.addHyperText($"    \e[1mOSDP  \e[m INVALID LENGTH");
                        break;
                        
                case OsdpLogRecordCode.InvalidPacketSqn:
                        representation.m_lineAttr.m_backColor = ui.StdColor.PastelRed;
                        representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;
                        representation.addHyperText($"    \e[1mOSDP  \e[m INVALID SQN");
                        break;

                default:
                        return false;
	}

	return true;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void representInvalidCrc(
	log.Representation* representation,
	char const* p,
	size_t size,
	uint_t foldFlags
	)
{
        representation.m_lineAttr.m_backColor = ui.StdColor.PastelRed;
        representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;

	if (!foldFlags)
	{
                representation.addHyperText($"[\e^+1\e[34m+\e[m] \e[1mOSDP  \e[m INVALID CRC %1 \e[34m%2"(
                        (*(p+1) & 0x80) ? "\u2190" : "\u2192",
                        *(p+1) & 0x7F
                        ));
	}
	else
	{
                uint16_t crc = (*(p+size-2)&0x00FF) + ((*(p+size-1) << 8)&0xFF00);
                representation.addHyperText($"[\e^-1\e[34m-\e[m] \e[1mOSDP\n"
                                            $"    Expected CRC16:\t\e[34m%(1; 04X)\n"
                                            $"    Received CRC16:\t\e^!%2,2\e[34m%(3; 04X)"(
			crc16_ccitt(p, size - 2, 0x1D0F),
                        size-2,
                        crc
			));
                        
                representation.m_lineAttr.m_backColor = ui.StdColor.White;
		representation.addBin(OsdpLogPartCode.RawPacket, p, size);
        }
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void representTimeout(
	log.Representation* representation,
	char const* p,
	size_t size,
	uint_t foldFlags
	)
{
        representation.m_lineAttr.m_backColor = ui.StdColor.PastelRed;
        representation.m_lineAttr.m_iconIdx = log.StdLogIcon.Packet;

	if (!foldFlags)
	{
                representation.addHyperText($"[\e^+1\e[34m+\e[m] \e[1mOSDP  \e[m TIMEOUT \u2190 \e[34m%1"(
                        *p
                        ));
	}
	else
	{
                representation.addHyperText($"[\e^-1\e[34m-\e[m] \e[1mOSDP\n"
                                            $"    Address:\t\e[34m%1\n"
                                            $"    Reply:\t\e[34mTimeout"(
			*p
			));
        }
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void representPacket(
	log.Representation* representation,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	OsdpHdr const* hdr = (OsdpHdr const*)p;
        OsdpScbHdr const* scbHdr = (OsdpScbHdr const*)(hdr + 1);
        OsdpScbData const* scbData = (OsdpScbData const*)(scbHdr + 1);
	OsdpCmdReply const* cmdReply = (hdr.m_ctrl & OsdpCtrl.Scb) ?
		(OsdpCmdReply const*)((char const*)scbHdr + scbHdr.m_length) :
		(OsdpCmdReply const*)(hdr + 1);

        if ((cmdReply.m_code != OsdpCmdReplyCode.osdp_POLL) && (!hdr.m_direction))
        {
                representation.m_lineAttr.m_backColor = ui.StdColor.PastelPurple;
        }
        else if ((cmdReply.m_code != OsdpCmdReplyCode.osdp_ACK) && (hdr.m_direction))
        {
		representation.m_lineAttr.m_backColor = ui.StdColor.PastelOrange;
        }
        else 
        {
		representation.m_lineAttr.m_backColor = ui.StdColor.PastelGray;
        }
                
	representation.m_lineAttr.m_iconIdx = hdr.m_direction ?
		log.StdLogIcon.RxPacket :
		log.StdLogIcon.TxPacket;

	if (!foldFlags)
	{
                representation.addHyperText($"[\e^+1\e[34m+\e[m] \e[1m%1\e[m %2 %3 \e[34m%4"(
                        (hdr.m_ctrl & OsdpCtrl.Scb) ? $"OSDP* " : $"OSDP  ",
                        (cmdReply.m_code != 0x76) ? typeof(OsdpCmdReplyCode).getValueString(cmdReply.m_code) : hdr.m_direction ? "osdp_CCRYPT" : "osdp_CHLNG",
                        hdr.m_direction ? "\u2190" : "\u2192",
                        hdr.m_address
                        ));
	}
	else
	{
                size_t scb_size = 0;
                size_t mac_size = 0; 
                
                representation.addHyperText($"[\e^-1\e[34m-\e[m] \e[1m%1\n"
                                            $"    Address:\t\e^!1,1\e[34m%2\n"
                                            $"    Length:\t\e^!2,2\e[34m%3\n"
                                            $"    Sequence:\t\e^!4,1\e[34m%4"(
			(hdr.m_ctrl & OsdpCtrl.Scb) ? $"OSDP* " : $"OSDP  ",
			hdr.m_address,
			hdr.m_length,
			hdr.m_sqn
			));
                      
                if (hdr.m_ctrl & OsdpCtrl.Scb)
		{
                        scb_size = scbHdr.m_length;
                        
                        representation.addHyperText($"    SEC_BLK_LEN:\t\e^!5,1\e[34m%1\n"
                                                    $"    SEC_BLK_TYPE:\t\e^!6,1\e[34m%(2; 02x)"(
                                scbHdr.m_length,
                                scbHdr.m_type
                                ));
                        
                        if (scbHdr.m_length > 2)
                        {
                            representation.addHyperText($"    SEC_BLK_DATA:\t\e^!7,1\e[34m%(1; 02x)"(
                                        scbData.m_data
                                        ));
                        }
                }
                
                representation.addHyperText($"    %1:\t\e^!%2,1\e[34m%3"(
                                hdr.m_direction ? $"Reply" : $"Command",
                                5 + scb_size,
                                (cmdReply.m_code != 0x76) ? typeof(OsdpCmdReplyCode).getValueString(cmdReply.m_code) : hdr.m_direction ? "osdp_CCRYPT" : "osdp_CHLNG"
                                ));
                
                if ((hdr.m_ctrl & OsdpCtrl.Scb) && (scbHdr.m_type >= 0x15) &&(scbHdr.m_type <= 0x18))
		{        
                        mac_size = 4;

                        OsdpMac const* mac = (OsdpMac const*)(p + size - 6);
                        representation.addHyperText($"    MAC:\t\e^!%1,4\e[34m0x%(2; 08x)"(
                                size - 6,
                                mac.m_mac
                                ));
		}  
                
                if (hdr.m_ctrl & OsdpCtrl.Crc)
		{
                        OsdpCrc const* crc = (OsdpCrc const*)(p + size - 2);
                        representation.addHyperText($"    CRC16:\t\e^!%1,2\e[34m0x%(2; 04x)"(
                                size - 2,
                                crc.m_crc
                                ));
		}  
                
                if ((hdr.m_ctrl & OsdpCtrl.Scb) && ((scbHdr.m_type == 0x17) || (scbHdr.m_type == 0x18)))
		{  
                        std.StringBuilder encrypted;
                        for (int i = 0; i < hdr.m_length - scb_size - mac_size - 8; i++) 
                        {
                                encrypted.append($"%02X "((*((char const*)p+6+scb_size+i))&0xFF));
                        }
                        
                        representation.addHyperText($"\n    Encrypted Data:\t\e^!%1,%2\e[34m%3"(
                                6 + scb_size,
                                hdr.m_length - scb_size - mac_size - 8,
                                encrypted.detachString()
                                ));
                }
                else 
                {
                        jnc.StructType* type;
                
                        switch (cmdReply.m_code)
                        {
                                // Commands
                                case OsdpCmdReplyCode.osdp_ID:
                                        type = typeof(OsdpId);
                                        break;
                                case OsdpCmdReplyCode.osdp_CAP:
                                        type = typeof(OsdpCap);
                                        break;
                                case OsdpCmdReplyCode.osdp_OUT:
                                        type = typeof(OsdpOut);
                                        break;
                                case OsdpCmdReplyCode.osdp_LED:
                                        type = typeof(OsdpLed);
                                        break;
                                case OsdpCmdReplyCode.osdp_BUZ:
                                        type = typeof(OsdpBuz);
                                        break;
                                case OsdpCmdReplyCode.osdp_COMSET:
                                        type = typeof(OsdpComset);
                                        break;
                                case OsdpCmdReplyCode.osdp_MFG:
                                        type = typeof(OsdpMfg);
                                        break;
                                case OsdpCmdReplyCode.osdp_SCRYPT:
                                        type = typeof(OsdpScrypt);
                                        break;

                                // Replies
                                case OsdpCmdReplyCode.osdp_NAK:
                                        type = typeof(OsdpNak);
                                        break;
                                case OsdpCmdReplyCode.osdp_PDID:
                                        type = typeof(OsdpPdid);
                                        break;
                                case OsdpCmdReplyCode.osdp_LSTATR:
                                        type = typeof(OsdpLstatr);
                                        break;
                                case OsdpCmdReplyCode.osdp_COM:
                                        type = typeof(OsdpCom);
                                        break;
                                case OsdpCmdReplyCode.osdp_MFGREP:
                                        type = typeof(OsdpMfgrep);
                                        break;
                                case OsdpCmdReplyCode.osdp_PDCAP:
                                        type = null;
                                        representOsdpPdcap(representation, p + 6 + scb_size, hdr.m_length - scb_size - mac_size - 8);
                                        break;
                                case OsdpCmdReplyCode.osdp_ISTATR:
                                        type = null;
                                        representOsdpIstatr(representation, p + 6 + scb_size, hdr.m_length - scb_size - mac_size - 8);
                                        break;
                                case OsdpCmdReplyCode.osdp_OSTATR:
                                        type = null;
                                        representOsdpOstatr(representation, p + 6 + scb_size, hdr.m_length - scb_size - mac_size - 8);
                                        break;
                                case OsdpCmdReplyCode.osdp_RAW:
                                        type = null;
                                        representOsdpRaw(representation, p + 6 + scb_size, hdr.m_length - scb_size - mac_size - 8);
                                        break;
                                case OsdpCmdReplyCode.osdp_RMACI:
                                        type = typeof(OsdpRmaci);
                                        break;

                                // Shared command / reply id
                                case OsdpCmdReplyCode.osdp_CHLNG: //0x76 used by CHLNG and CCRYPT
                                        if (hdr.m_direction) 
                                        {
                                                type = typeof(OsdpCcrypt);
                                        }
                                        else
                                        {
                                                type = typeof(OsdpChlng);
                                        }
                                        break;
                                
                                // Default
                                default:
                                        type = null;
                                        break;
                        }

                        if (type)
                        {
                                representation.addPlainText($" ");

                                log.representStruct(
                                    representation,
                                    type,
                                    $"Data",
                                    OsdpLogPartCode.RawPacket,
                                    p + 6 + scb_size,
                                    6 + scb_size,
                                    1, 0, 0
                                    );
                        }
                }              

		representation.m_lineAttr.m_backColor = ui.StdColor.White;
		representation.addBin(OsdpLogPartCode.RawPacket, p, size);
	}
}

//..............................................................................
