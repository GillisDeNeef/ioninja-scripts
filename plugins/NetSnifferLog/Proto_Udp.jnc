//..............................................................................
//
// Sniffer log UDP packets handling
//

//..............................................................................

void representUdpDigest(
	log.Representation* representation,
	io.IpHdr const* ipHdr,
	void const* p,
	size_t size,
	size_t baseOffset
	)
{
	if (baseOffset + sizeof(io.UdpHdr) > size)
	{
		representation.addHyperText($"$(formatIpLogText(ipHdr)) [BROKEN PACKET]");
		return;
	}

	io.UdpHdr const* udpHdr = (io.UdpHdr const*)(p + baseOffset);
	size_t dataSize = udpHdr.m_length - sizeof(io.UdpHdr);
	baseOffset += sizeof(io.UdpHdr);

	char const* lengthString;

	if (baseOffset + dataSize <= size)
	{
		lengthString = $"$dataSize bytes";
	}
	else
	{
		lengthString = $"INVALID SIZE: $dataSize bytes";
		dataSize = size - baseOffset;
	}

	representation.addHyperText(std.format(
		"\e[1mUDP \e[10;34m%s:%d\e[m > \e[34m%s:%d\e[m (%s)",
		formatIpString(ipHdr.m_srcAddress),
		udpHdr.m_srcPort,
		formatIpString(ipHdr.m_dstAddress),
		udpHdr.m_dstPort,
		lengthString
		));

	representPacketData(representation, p, size, baseOffset, dataSize);
}

void representUdpHdr(
	log.Representation* representation,
	std.Array* protoRangeArray,
	io.IpHdr const* ipHdr,
	void const* p,
	size_t size,
	size_t baseOffset,
	uint_t foldFlags
	)
{
	representation.m_lineAttr.m_backColor = ProtoColor.Udp;

	if (baseOffset + sizeof(io.UdpHdr) > size)
	{
		representation.addHyperText($"$(formatIpLogText(ipHdr)) [BROKEN PACKET]");
		return;
	}

	io.UdpHdr const* udpHdr = (io.UdpHdr const*)(p + baseOffset);

	if (foldFlags & ProtoFoldFlag.Udp)
		representation.addHyperText(std.format(
			"[\e^-%d\e[34m-\e[m] \e[1mUDP\n"
			"    \e[90mSRC:      \e^!%d,%d\e[34m%d\n"
			"    \e[90mDST:      \e^!%d,%d\e[34m%d\n"
			"    \e[90mLENGTH:   \e^!%d,%d\e[34m%d\n"
			"    \e[90mCHECKSUM: \e^!%d,%d\e[34m%04Xh",

			ProtoFoldFlag.Udp,

			baseOffset + offsetof(udpHdr.m_srcPort),
			sizeof(udpHdr.m_srcPort),
			udpHdr.m_srcPort,

			baseOffset + offsetof(udpHdr.m_dstPort),
			sizeof(udpHdr.m_dstPort),
			udpHdr.m_dstPort,

			baseOffset + offsetof(udpHdr.m_length),
			sizeof(udpHdr.m_length),
			udpHdr.m_length,

			baseOffset + offsetof(udpHdr.m_checksum),
			sizeof(udpHdr.m_checksum),
			udpHdr.m_checksum
			));
	else
		representation.addHyperText(std.format(
			"[\e^+%d\e[34m+\e[m] \e[1mUDP \e^!%d,%d\e[10;34m%d\e[m > \e^!%d,%d\e[34m%d\e[m",
			ProtoFoldFlag.Udp,

			baseOffset + offsetof(udpHdr.m_srcPort),
			sizeof(udpHdr.m_srcPort),
			udpHdr.m_srcPort,

			baseOffset + offsetof(udpHdr.m_dstPort),
			sizeof(udpHdr.m_dstPort),
			udpHdr.m_dstPort
			));

	ProtoRange range = { sizeof(io.UdpHdr), ProtoColor.Udp }
	protoRangeArray.append(range);

	if (udpHdr.m_length <= sizeof(io.UdpHdr))
		return;

	representation.m_lineAttr.m_backColor = ProtoColor.UdpPayload;
	size_t dataSize = udpHdr.m_length - sizeof(io.UdpHdr);

	range = { dataSize, ProtoColor.UdpPayload };
	protoRangeArray.append(range);

	if (foldFlags & ProtoFoldFlag.UdpPayload)
	{
		representation.addHyperText(std.format(
			"[\e^-%d\e[34m-\e[m] \e[1mUDP\e[m payload",
			ProtoFoldFlag.UdpPayload
			));

		representation.m_lineAttr.m_backColor = ui.ColorFlags.Transparent;
		representation.addBin(udpHdr + 1, dataSize);
	}
	else
		representation.addHyperText(std.format(
			"[\e^+%d\e[34m+\e[m] \e[1mUDP\e[m payload (%d bytes)",
			ProtoFoldFlag.UdpPayload,
			dataSize
			));
}

//..............................................................................
