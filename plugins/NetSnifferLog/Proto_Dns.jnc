//..............................................................................
//
// Sniffer log DNS packets handling
//

import "std_String.jnc"

//..............................................................................

class DnsProtoParser: AppProtoParser
{
protected:
	char const* m_name;

public:
	construct(char const* name = "DNS")
	{
		m_name = name;
	}

	override void representDigest(
		log.Representation* representation,
		char const* srcString,
		char const* dstString,
		void const* p,
		size_t size,
		int payloadPreviewIconIdx
		);

	override void representDetails(
		log.Representation* representation,
		std.Array* protoRangeArray,
		void const* p,
		size_t size,
		size_t baseOffset,
		uint_t foldFlags
		);

protected:
	virtual decodeName(std.StringBuilder* string)
	{
	}

	void const* formatNameLink(
		std.StringBuilder* string,
		void const* p,
		void const* end,
		void const* base,
		size_t baseOffset
		);

	void const* representQuestionRrTable(
		log.Representation* representation,
		std.StringBuilder* string,
		char const* name,
		size_t count,
		void const* p,
		void const* end,
		void const* base,
		size_t baseOffset
		);

	void const* representAnswerRrTable(
		log.Representation* representation,
		std.StringBuilder* string,
		char const* name,
		size_t count,
		void const* p,
		void const* end,
		void const* base,
		size_t baseOffset
		);

	void const* representQuestionRr(
		log.Representation* representation,
		std.StringBuilder* string,
		size_t i,
		void const* p,
		void const* end,
		void const* base,
		size_t baseOffset
		);

	void const* representAnswerRr(
		log.Representation* representation,
		std.StringBuilder* string,
		size_t i,
		void const* p,
		void const* end,
		void const* base,
		size_t baseOffset
		);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void DnsProtoParser.representDigest(
	log.Representation* representation,
	char const* srcString,
	char const* dstString,
	void const* p,
	size_t size,
	int payloadPreviewIconIdx
	)
{
	representSimpleProtoDigest(
		representation,
		typeof(io.DnsHdr),
		m_name,
		srcString,
		dstString,
		p,
		size,
		payloadPreviewIconIdx
		);
}

void DnsProtoParser.representDetails(
	log.Representation* representation,
	std.Array* protoRangeArray,
	void const* p,
	size_t size,
	size_t baseOffset,
	uint_t foldFlags
	)
{
	representation.m_lineAttr.m_backColor = ProtoColor.AppLayer;

	if (size < sizeof(io.DnsHdr))
	{
		representation.addHyperText("\e[1mDNS\e[m [INCOMPLETE]");
		return;
	}

	log.representStruct(
		representation,
		typeof(io.DnsHdr),
		m_name,
		NetSnifferLogPartCode.RawPacket,
		p,
		baseOffset,
		foldFlags,
		ProtoFoldFlag.AppLayer
		);

	ProtoRange range = { baseOffset, sizeof(io.DnsHdr), ProtoColor.AppLayer }
	protoRangeArray.append(range);

	io.DnsHdr const* hdr = (io.DnsHdr const*)p;
	p += sizeof(io.DnsHdr);
	size -= sizeof(io.DnsHdr);

	representation.m_lineAttr.m_backColor = ProtoColor.Payload;

	void const* payload = p;
	void const* end = p + size;
	size_t payloadOffset = baseOffset + sizeof(io.DnsHdr);

	if (foldFlags & ProtoFoldFlag.Payload)
	{
		representation.addHyperText($"[\e^-%1\e[34m-\e[m] \e[1mDNS\e[m RRs"(ProtoFoldFlag.Payload));

		std.StringBuilder string;

		if (hdr.m_questionRrCount)
			p = representQuestionRrTable(
				representation,
				string,
				"Question RRs",
				hdr.m_questionRrCount,
				p,
				end,
				hdr,
				baseOffset
				);

		if (hdr.m_answerRrCount)
			p = representAnswerRrTable(
				representation,
				string,
				"Answer RRs",
				hdr.m_answerRrCount,
				p,
				end,
				hdr,
				baseOffset
				);

		if (hdr.m_authorityRrCount)
			p = representAnswerRrTable(
				representation,
				string,
				"Authority RRs",
				hdr.m_authorityRrCount,
				p,
				end,
				hdr,
				baseOffset
				);

		if (hdr.m_additionalRrCount)
			p = representAnswerRrTable(
				representation,
				string,
				"Additional RRs",
				hdr.m_additionalRrCount,
				p,
				end,
				hdr,
				baseOffset
				);
	}
	else
	{
		for (size_t i = 0; p < end && i < hdr.m_questionRrCount; i++)
			p = scanDnsQuestionRr(p, end);

		size_t count =
			hdr.m_answerRrCount +
			hdr.m_authorityRrCount +
			hdr.m_additionalRrCount;

		for (size_t i = 0; p < end && i < count; i++)
			p = scanDnsAnswerRr(p, end);

		representation.addHyperText(
			$"[\e^+%1\e[34m+\e[m] \e[1mDNS\e[m RRs (%2 bytes)"(
			ProtoFoldFlag.Payload,
			p - payload
			));
	}

	range = { payloadOffset, p - payload, ProtoColor.Payload };
	protoRangeArray.append(range);
}

void const* DnsProtoParser.formatNameLink(
	std.StringBuilder* string,
	void const* p,
	void const* end,
	void const* base,
	size_t baseOffset
	)
{
	void const* p0 = p;
	string.clear();
	p = io.formatDnsName(string, p, end, base);
	size_t offset = baseOffset + p0 - base;
	size_t length = p - p0;
	decodeName(string);
	string.insert(0, $"\e^!0x%x,%2,%3\e[34m"(NetSnifferLogPartCode.RawPacket, offset, length));
	string.append("\e[m");
	return p;
}

void const* scanDnsQuestionRr(
	void const* p,
	void const* end
	)
{
	p = io.scanDnsName(p, end);
	return end - p < sizeof(io.DnsQuestionRrSuffix) ? end : p + sizeof(io.DnsQuestionRrSuffix);
}

void const* scanDnsAnswerRr(
	void const* p,
	void const* end
	)
{
	p = io.scanDnsName(p, end);
	return end - p < sizeof(io.DnsAnswerRrSuffix) ? end : p + sizeof(io.DnsAnswerRrSuffix);
}

void const* DnsProtoParser.representQuestionRrTable(
	log.Representation* representation,
	std.StringBuilder* string,
	char const* name,
	size_t count,
	void const* p,
	void const* end,
	void const* base,
	size_t baseOffset
	)
{
	representation.addHyperText($"    $name:");

	for (size_t i = 0; p < end && i < count; i++)
		p = representQuestionRr(representation, string, i, p, end, base, baseOffset);

	return p;
}

void const* DnsProtoParser.representAnswerRrTable(
	log.Representation* representation,
	std.StringBuilder* string,
	char const* name,
	size_t count,
	void const* p,
	void const* end,
	void const* base,
	size_t baseOffset
	)
{
	representation.addHyperText($"    $name:");

	for (size_t i = 0; p < end && i < count; i++)
		p = representAnswerRr(representation, string, i, p, end, base, baseOffset);

	return p;
}

void const* DnsProtoParser.representQuestionRr(
	log.Representation* representation,
	std.StringBuilder* string,
	size_t i,
	void const* p,
	void const* end,
	void const* base,
	size_t baseOffset
	)
{
	if (p >= end)
	{
		representation.addHyperText($"%(1;10d): [INCOMPLETE-RR]"(i + 1));
		return end;
	}

	p = formatNameLink(string, p, end, base, baseOffset);

	if (end - p < sizeof(io.DnsQuestionRrSuffix))
	{
		representation.addHyperText(
			$"%(1;10d): Name: %2\n"
			$"%(3;10c)  [INCOMPLETE-RR]"(
			i + 1,
			string.m_sz,
			' '
			));

		return end;
	}

	representation.addHyperText($"%(1;10d): Name:\t%2"(i + 1, string.m_sz));

	log.representStruct(
		representation,
		typeof(io.DnsQuestionRrSuffix),,
		NetSnifferLogPartCode.RawPacket,
		p,
		baseOffset + p - base,
		0,
		0,
		2
		);

	return p + sizeof(io.DnsQuestionRrSuffix);
}

void const* DnsProtoParser.representAnswerRr(
	log.Representation* representation,
	std.StringBuilder* string,
	size_t i,
	void const* p,
	void const* end,
	void const* base,
	size_t baseOffset
	)
{
	if (p >= end)
	{
		representation.addHyperText($"%(1;10d): [INCOMPLETE-RR]"(i + 1));
		return end;
	}

	p = formatNameLink(string, p, end, base, baseOffset);

	if (end - p < sizeof(io.DnsAnswerRrSuffix))
	{
		representation.addHyperText(
			$"%(1;10d): Name: %2\n"
			$"%(3;10c)  [INCOMPLETE-RR]"(
			i + 1,
			string.m_sz,
			' '
			));

		return end;
	}

	representation.addHyperText($"%(1;10d): Name:\t%2"(i + 1, string.m_sz));

	log.representStruct(
		representation,
		typeof(io.DnsAnswerRrSuffix),,
		NetSnifferLogPartCode.RawPacket,
		p,
		baseOffset + p - base,
		0,
		0,
		2
		);

	io.DnsAnswerRrSuffix const* suffix = (io.DnsAnswerRrSuffix const*)p;
	p += sizeof(io.DnsAnswerRrSuffix);

	if (end - p < suffix.m_dataLength)
	{
		representation.addHyperText($"%(1;12c)[INCOMPLETE-RR]"(' '));
		return end;
	}

	char const* dataString;

	switch (suffix.m_type)
	{
	case io.DnsType.A:
		dataString = ((io.Address_ip4 const*)p).getString();
		break;

	case io.DnsType.AAAA:
		dataString = ((io.Address_ip6 const*)p).getString();
		break;

	case io.DnsType.CNAME:
		dataString = io.formatDnsName(p, end, base);
		break;
	}

	if (dataString)
		representation.addHyperText(
			$"%(1;12c)Data:\t\e^!0x%x,%3,%4\e[34m%5"(
			' ',
			NetSnifferLogPartCode.RawPacket,
			baseOffset + p - base,
			suffix.m_dataLength,
			dataString
			));

	return p + suffix.m_dataLength;
}

//..............................................................................

enum NetBiosNameType: char
{
	Workstation               = 0x00,
	MessengerService          = 0x03,
	RemoteAccessService       = 0x06,
	DomainMasterBrowser       = 0x1b,
	DomainController          = 0x1c,
	MasterBrowser             = 0x1d,
	FileService               = 0x20,
	RemoteAccessServiceClient = 0x21,
}

class NbnsProtoParser: DnsProtoParser
{
	construct()
	{
		basetype.construct("NBNS");
	}

protected:
	override decodeName(std.StringBuilder* string)
	{
		size_t originalLength = string.m_length;
		size_t length = originalLength / 2;
		string.append(' ',  length);

		for (size_t i = 0, j = 0; i < length; i++, j += 2)
			string[originalLength + i] = ((string[i] - 'A') << 4) | (string[i + 1] - 'A');

		string.remove(0, originalLength);

		if (length == 16) // last character is the type
		{
			string.chop(1);
			string.trimRight();
			string.append($" (%1)"(typeof(NetBiosNameType).getValueType(string[15])));
		}
	}
}

//..............................................................................

construct()
{
	static DnsProtoParser dns;
	static NbnsProtoParser nbns;
	static DnsProtoParser llmnr("LLMNR");

	g_udpPortAppProtoParserMap[53] = dns;
	g_udpPortAppProtoParserMap[137] = nbns;
	g_udpPortAppProtoParserMap[5355] = llmnr;
}

//..............................................................................
