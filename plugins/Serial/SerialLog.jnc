//.............................................................................
//
// Serial log packet declarations and representer
//

//.............................................................................

enum SerialLogRecordCode
{
	PortOpened    = 1 | log.RecordCodeFlags.Foldable,
	PortOpenError = 2,
	PortClosed,
	BaudRateChanged,
	DataBitsChanged,
	StopBitsChanged,
	ParityChanged,
	FlowControlChanged,
	RtsChanged,
	DtrChanged,
	StatusLineChanged,
}

enum StatusLinePartCode
{
	Prefix = 1 | log.PartCodeFlags.MergeableForward,
	Suffix = 1 | log.PartCodeFlags.Mergeable,
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct SerialOpenParams
{
	uint_t m_baudRate;
	uint_t m_flowControl;
	uint_t m_dataBits;
	uint_t m_stopBits;
	uint_t m_parity;

	// followed by port name
};

//.............................................................................

bool representSerialLog (
	log.RepresenterTarget* target,
	uint_t recordCode,
	void const* p,
	size_t size,
	uint_t foldFlags
	)
{
	switch (recordCode)
	{
	case SerialLogRecordCode.PortOpened:
		SerialOpenParams const* params = (SerialOpenParams const*) p;
		char const* name = (char const*) (params + 1);

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Play;
		target.m_lineAttr.m_backColor = log.StdLogColor.Start;

		if (!(foldFlags & 1))
			target.addHyperText ($"[\e^+1\e[34m+\e[m] Opened port \e[34m$name\e[m at \e[34m$(params.m_baudRate)\e[m bps");
		else
			target.addHyperText (
				$"[\e^-1\e[34m-\e[m] Opened port \e[34m$name\n"
				$"    \e[90mBaud rate:    \e[34m$(params.m_baudRate)\e[m bps\n"
				$"    \e[90mData bits:    \e[34m$(params.m_dataBits)\n"
				$"    \e[90mStop bits:    \e[34m$(params.m_stopBits)\n"
				$"    \e[90mParity:       \e[34m$(params.m_parity)\n"
				$"    \e[90mFlow control: \e[34m$(params.m_flowControl)"
				);

		break;

	case SerialLogRecordCode.PortClosed:
		char const* name = (char const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Pause;
		target.m_lineAttr.m_backColor = log.StdLogColor.Stop;
		target.addHyperText ($"Port \e[34m$name\e[m closed");
		break;

	case SerialLogRecordCode.PortOpenError:
		jnc.Error const* error = (jnc.Error const*) p;
		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Error;
		target.m_lineAttr.m_backColor = log.StdLogColor.Error;
		target.addHyperText ($"Unable to open port ($(error.m_description))");
		break;

	case SerialLogRecordCode.BaudRateChanged:
		uint_t baudRate = *(uint_t const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Baud rate set to \e[34m$baudRate\e[m bps");
		break;

	case SerialLogRecordCode.DataBitsChanged:
		uint_t dataBits = *(uint_t const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Data bits set to \e[34m$dataBits");
		break;

	case SerialLogRecordCode.StopBitsChanged:
		uint_t stopBits = *(uint_t const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Stop bits set to \e[34m$stopBits");
		break;

	case SerialLogRecordCode.ParityChanged:
		uint_t parity = *(uint_t const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Parity set to \e[34m$parity");
		break;

	case SerialLogRecordCode.FlowControlChanged:
		uint_t flowControl = *(uint_t const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"Flow control set to \e[34m$flowControl");
		break;

	case SerialLogRecordCode.RtsChanged:
		bool rts = *(bool const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"\e[34mRTS\e[m set to $rts");
		break;

	case SerialLogRecordCode.DtrChanged:
		bool dtr = *(bool const*) p;

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText ($"\e[34mDTR\e[m set to $dtr");
		break;

	case SerialLogRecordCode.StatusLineChanged:
		uint_t lines = ((uint_t const*) p) [0];
		uint_t mask  = ((uint_t const*) p) [1];

		target.m_lineAttr.m_iconIdx = log.StdLogIcon.Info;
		target.m_lineAttr.m_backColor = log.StdLogColor.Info;
		target.addHyperText (StatusLinePartCode.Prefix, "Status line(s) changed:");

		if (mask & io.SerialStatusLines.Dsr)
		{
			bool dsr = (lines & io.SerialStatusLines.Dsr) != 0;
			target.addHyperText (StatusLinePartCode.Suffix, $" \e[34mDSR\e[m:$dsr");
		}

		if (mask & io.SerialStatusLines.Cts)
		{
			bool cts = (lines & io.SerialStatusLines.Cts) != 0;
			target.addHyperText (StatusLinePartCode.Suffix, $" \e[34mCTS\e[m:$cts");
		}

		if (mask & io.SerialStatusLines.Dcd)
		{
			bool dcd = (lines & io.SerialStatusLines.Dcd) != 0;
			target.addHyperText (StatusLinePartCode.Suffix, $" \e[34mDCD\e[m:$dcd");
		}

		break;

	default:
		return false;
	}

	return true;
}

//.............................................................................

class SerialLogFilter: log.Filter
{
	bool m_isSettingChangedVisible;
	bool m_isControlLineChangedVisible;
	bool m_isStatusLineChangedVisible;

	construct ();

	override bool filter (
		uint_t recordCode,
		void const* p,
		size_t size
		);
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

SerialLogFilter.construct ()
{
	m_isSettingChangedVisible = true;
	m_isControlLineChangedVisible = true;
	m_isStatusLineChangedVisible = true;
}

bool SerialLogFilter.filter (
	uint_t recordCode,
	void const* p,
	size_t size
	)
{
	switch (recordCode)
	{
	case SerialLogRecordCode.BaudRateChanged:
	case SerialLogRecordCode.DataBitsChanged:
	case SerialLogRecordCode.StopBitsChanged:
	case SerialLogRecordCode.ParityChanged:
	case SerialLogRecordCode.FlowControlChanged:
		return m_isSettingChangedVisible;

	case SerialLogRecordCode.RtsChanged:
	case SerialLogRecordCode.DtrChanged:
		return m_isControlLineChangedVisible;

	case SerialLogRecordCode.StatusLineChanged:
		return m_isStatusLineChangedVisible;

	default:
		return true; // everything else is visible
	}
}

//.............................................................................
