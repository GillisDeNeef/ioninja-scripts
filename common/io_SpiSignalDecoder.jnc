//..............................................................................
//
// SPI clock-based signal-edge decoding
//

import "std_Buffer.jnc"

namespace io {

//..............................................................................

enum SpiDecodeResult
{
	Continue,
	Packet,
	FramingError,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class SpiSignalDecoder
{
protected:
	bool m_cpol;
	bool m_cpha;
	bool m_isLittleEndian;

	bool m_lastSclk;
	bool m_lastSs;

	uint8_t m_mosiChar;
	uint8_t m_misoChar;
	uint8_t m_bit;

public:
	std.Buffer readonly m_mosiBuffer;
	std.Buffer readonly m_misoBuffer;

public:
	start (
		uint_t spiMode,
		bool isLittleEndian
		);

	SpiDecodeResult add (
		bool sclk,
		bool mosi,
		bool miso,
		bool ss
		);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

SpiSignalDecoder.start (
	uint_t spiMode,
	bool isLittleEndian
	)
{
	m_cpol = spiMode > 1;
	m_cpha = spiMode & 1;
	m_isLittleEndian = isLittleEndian;
	m_lastSs = true;
}

SpiDecodeResult SpiSignalDecoder.add (
	bool sclk,
	bool mosi,
	bool miso,
	bool ss
	)
{
	static bool spiSelectorTable [2] [2] [2] =
	{
		// CPOL 0
		{
			// CPHA 0
			{
				false, // SCLK 0
				true,  // SCLK 1
			},

			// CPHA 1
			{
				true,  // SCLK 0
				false, // SCLK 1
			},
		},

		// CPOL 1
		{
			// CPHA 0
			{
				true,  // SCLK 0
				false, // SCLK 1
			},

			// CPHA 1
			{
				false, // SCLK 0
				true,  // SCLK 1
			},
		},
	}

	if (ss)
	{
		if (m_lastSs)
			return SpiDecodeResult.Continue;

		m_lastSs = true;

		return
			m_bit ? SpiDecodeResult.FramingError :
			m_mosiBuffer.m_size ? SpiDecodeResult.Packet : SpiDecodeResult.Continue;
	}

	if (m_lastSs)
	{
		m_lastSs = false;
		m_lastSclk = m_cpol;
		m_mosiBuffer.clear ();
		m_misoBuffer.clear ();
		m_mosiChar = 0;
		m_misoChar = 0;
		m_bit = 0;
	}

	if (sclk == m_lastSclk)
		return SpiDecodeResult.Continue;

	m_lastSclk = sclk;

	if (spiSelectorTable [m_cpol] [m_cpha] [sclk])
	{
		if (!m_bit)
			m_bit = m_isLittleEndian ? 0x01 : 0x80;

		if (mosi)
			m_mosiChar |= m_bit;

		if (miso)
			m_misoChar |= m_bit;

		m_isLittleEndian ? m_bit <<= 1 : m_bit >>= 1;

		if (!m_bit)
		{
			m_mosiBuffer.append (&m_mosiChar, 1);
			m_misoBuffer.append (&m_misoChar, 1);

			m_mosiChar = 0;
			m_misoChar = 0;
		}
	}

	return SpiDecodeResult.Continue;
}

//..............................................................................

} // namespace io
