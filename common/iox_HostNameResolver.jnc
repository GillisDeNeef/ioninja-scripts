//..............................................................................
//
// Host name resolver (high-level interface, encapsulates logging and UI)
//

import "io_base.jncx"
import "io_HostNameResolver.jnc"

namespace iox {

//! \addtogroup common-io
//! @{

//..............................................................................

class HostNameResolver
{
public:
	enum State
	{
		Idle,
		Error,
		Resolving,
		Resolved,
	}

protected:
	doc.PluginHost* m_pluginHost;
	io.HostNameResolver m_resolver;
	char const* m_addressString;
	uint_t m_syncId;

	property m_logWriter
	{
		log.Writer* get()
		{
			return m_pluginHost.m_log.m_writer;
		}
	}

public:
	State bindable readonly m_state;
	io.SocketAddress readonly m_address;
	uint_t m_defaultPort; // freely adjustible

public:
	construct(doc.PluginHost* pluginHost)
	{
		m_pluginHost = pluginHost;
	}

	bool errorcode resolve(char const* addressString);
	void cancel();

protected:
	void handleResolveError(std.Error const* error);

	onResolverEvent(
		uint_t syncId,
		io.HostNameResolverEvents triggeredEvents
		);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

bool errorcode HostNameResolver.resolve(char const* addressString)
{
	cancel();

	io.SocketAddress address;
	bool isDirectAddress = try address.parse(addressString);
	if (isDirectAddress)
	{
		if (!address.m_port)
			address.m_port = m_defaultPort;

		m_address = address;
		m_state = State.Resolved;
		return true;
	}

	m_syncId++;
	m_logWriter.write(SocketLogRecordCode.Resolving, addressString);
	m_logWriter.sync(m_syncId);
	m_resolver.resolve(addressString);
	m_addressString = addressString;

	m_resolver.wait(
		io.HostNameResolverEvents.Resolved | io.HostNameResolverEvents.Error,
		onResolverEvent~(m_syncId) @ m_pluginHost.m_mainThreadScheduler
		);

	m_state = State.Resolving;
	return true;

catch:
	handleResolveError(std.getLastError());
	return false;
}

void HostNameResolver.cancel()
{
	if (m_state != State.Resolving)
	{
		m_state = State.Idle;
		return;
	}

	m_logWriter.write(SocketLogRecordCode.ResolveCancelled);
	m_resolver.cancel();
	m_syncId++;
	m_state = State.Idle;
}

HostNameResolver.handleResolveError(std.Error const* error)
{
	m_logWriter.write(SocketLogRecordCode.ResolveError, error);
	m_resolver.cancel();
	m_state = State.Error;
}

HostNameResolver.onResolverEvent(
	uint_t syncId,
	io.HostNameResolverEvents triggeredEvents
	)
{
	if (syncId != m_syncId)
		return;

	if (syncId != m_pluginHost.m_log.m_syncId)
		m_logWriter.write(SocketLogRecordCode.ResolveCompletedPrefix, m_addressString);

	if (triggeredEvents & io.HostNameResolverEvents.Error)
	{
		handleResolveError(m_resolver.m_error);
		return;
	}

	m_logWriter.write(
		SocketLogRecordCode.ResolveCompleted,
		m_resolver.m_addressTable,
		sizeof(io.SocketAddress)
		);

	m_address = m_resolver.m_addressTable[0];
	if (!m_address.m_port)
		m_address.m_port = m_defaultPort;

	m_state = State.Resolved;
}

//..............................................................................

//! @}

} // namespace iol
