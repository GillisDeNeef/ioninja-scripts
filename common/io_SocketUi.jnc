//..............................................................................
//
// Socket & network adapter user interface
//

import "gui_Base.jnc"
import "gui_PropertyGrid.jnc"
import "io_base.jncx"
import "io_Socket.jnc"
import "io_NetworkAdapter.jnc"
import "io_BufferUi.jnc"

namespace io {

//..............................................................................

enum NetworkAdapterUsage
{
	Connection,
	Listener,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

gui.EnumPropertyOption const* createNetworkAdapterOptionArray (NetworkAdapterUsage usage)
{
	size_t addressCount;
	io.NetworkAdapterDesc const* adapterList = io.createNetworkAdapterDescList (null, &addressCount);

	gui.EnumPropertyOption* optionArray;
	gui.EnumPropertyOption* option;

	switch (usage)
	{
	case NetworkAdapterUsage.Connection:
		addressCount++; // include 'Auto'
		optionArray = new gui.EnumPropertyOption [addressCount];
		option = optionArray;

		option.m_text = "Auto";
		option.m_value = null;
		option++;
		break;

	case NetworkAdapterUsage.Listener:
		static io.SocketAddress autoAddress_ip4 = { m_family = io.AddressFamily.Ip4 }
		static io.SocketAddress autoAddress_ip6 = { m_family = io.AddressFamily.Ip6 }

		addressCount += 2; // include 'All IPv4/IPv6 adapters'
		optionArray = new gui.EnumPropertyOption [addressCount];
		option = optionArray;

		option.m_text = "All IPv4 adapters";
		option.m_value = &autoAddress_ip4;
		option++;

		option.m_text = "All IPv6 adapters";
		option.m_value = &autoAddress_ip6;
		option++;
		break;
	}

	io.NetworkAdapterDesc const* adapter = adapterList;
	for (; adapter; adapter = adapter.m_next)
	{
		io.NetworkAdapterAddress const* address = adapter.m_address;
		for (; address; address = address.m_next, option++)
		{
			option.m_text = $"%1 - %2" (
				adapter.m_description,
				address.m_address.getString ()
				);

			option.m_value = &address.m_address;
		}
	}

	return optionArray;
}

//..............................................................................

gui.EnumProperty* createNetworkAdapterProperty (
	gui.PropertyGrid* propertyGrid,
	gui.GroupProperty* group = null,
	gui.Property* insertBefore = null,
	NetworkAdapterUsage usage,
	char const* name,
	char const* toolTipText
	)
{
	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray (usage);
	size_t optionCount = dynamic countof (optionArray);

	return propertyGrid.createEnumProperty (
		group,
		insertBefore,
		name,
		toolTipText,
		optionArray,
		optionCount
		);
}

gui.EnumProperty* createNetworkAdapterProperty (
	gui.PropertyGrid* propertyGrid,
	NetworkAdapterUsage usage,
	char const* name,
	char const* toolTipText
	)
{
	return createNetworkAdapterProperty (propertyGrid,,, usage, name, toolTipText);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

gui.ComboBox*
createNetworkAdapterComboBox (
	gui.ToolBar* toolBar,
	NetworkAdapterUsage usage,
	uint_t width = -1
	)
{
	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray (usage);
	size_t optionCount = dynamic countof (optionArray);

	gui.ComboBox* comboBox = toolBar.addComboBox (width);

	for (size_t i = 0; i < optionCount; i++)
		comboBox.addItem (
			optionArray [i].m_text,
			optionArray [i].m_value
			);

	return comboBox;
}

//..............................................................................

class SocketPropertySet
{
	bitflag enum PropertyId
	{
		RemoteAddress,
		RemotePort,
		UseLocalAddress,
		ClientAdapter,
		ServerAdapter,
		LocalPort,
		ReuseLocalAddress,
		TcpKeepAlive,
		TcpNagle,
		TcpReset,

		AllUdpClient =
			RemoteAddress |
			RemotePort |
			ServerAdapter |
			LocalPort |
			ReuseLocalAddress,

		AllTcpClient =
			RemoteAddress |
			RemotePort |
			UseLocalAddress |
			ClientAdapter |
			LocalPort |
			ReuseLocalAddress |
			TcpKeepAlive |
			TcpNagle |
			TcpReset,

		AllTcpServer =
			ServerAdapter |
			LocalPort |
			ReuseLocalAddress |
			TcpKeepAlive |
			TcpNagle |
			TcpReset,
	}

	enum Defaults
	{
		RemotePort   = 80,
		LocalPort    = 0,
		TcpKeepAlive = false,
		TcpNagle     = false,
		TcpReset     = false,
	}

	static char DefaultRemoteAddress [] = "ioninja.com";

	gui.StringProperty* m_remoteAddressProp;
	gui.IntProperty* m_remotePortProp;
	gui.BoolProperty* m_useLocalAddressProp;
	gui.EnumProperty* m_adapterProp;
	gui.IntProperty* m_localPortProp;
	gui.BoolProperty* m_reuseLocalAddressProp;
	gui.BoolProperty* m_tcpKeepAliveProp;
	gui.BoolProperty* m_tcpNagleProp;
	gui.BoolProperty* m_tcpResetProp;

	uint16_t m_defaultRemotePort = Defaults.RemotePort;
	uint16_t m_defaultLocalPort = Defaults.LocalPort;

	createProperties (
		gui.PropertyGrid* propertyGrid,
		gui.GroupProperty* group = null,
		gui.Property* insertBefore = null,
		PropertyId propertySet = PropertyId.AllTcpClient
		);

	load (doc.Storage* storage);
	save (doc.Storage* storage);
	restoreDefaults ();
}

SocketPropertySet.createProperties (
	gui.PropertyGrid* propertyGrid,
	gui.GroupProperty* group,
	gui.Property* insertBefore,
	PropertyId propertySet
	)
{
	if (propertySet & PropertyId.RemoteAddress)
		m_remoteAddressProp = propertyGrid.createStringProperty (
			group,
			insertBefore,
			"Remote address",
			"Remote address to connect to (IP-address or host-name followed by ':' port)"
			);

	if (propertySet & PropertyId.RemotePort)
		m_remotePortProp = propertyGrid.createIntProperty (
			group,
			insertBefore,
			"Remote TCP port (default)",
			"Remote TCP port to connect to (if not specified in remote address)"
			);

	if (propertySet & PropertyId.UseLocalAddress)
		m_useLocalAddressProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use local address",
			"Bind socket to the specified local address"
			);

	if (propertySet & (PropertyId.ClientAdapter | PropertyId.ServerAdapter))
		m_adapterProp = io.createNetworkAdapterProperty (
			propertyGrid,
			group,
			insertBefore,
			(propertySet & PropertyId.ClientAdapter) ?
				io.NetworkAdapterUsage.Connection :
				io.NetworkAdapterUsage.Listener,
			"Adapter",
			"Network adapter to bind to"
			);

	if (propertySet & PropertyId.LocalPort)
		m_localPortProp = propertyGrid.createIntProperty (
			group,,
			"Local TCP port",
			"Local TCP port to bind to"
			);

	if (propertySet & PropertyId.ReuseLocalAddress)
		m_reuseLocalAddressProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Reuse address",
			"Allow multiple sockets to share the same local address"
			);

	if (propertySet & PropertyId.TcpKeepAlive)
		m_tcpKeepAliveProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use TCP keep-alives",
			"Specify whether to detect lost connections with TCP keep-alive probes"
			);

	if (propertySet & PropertyId.TcpNagle)
		m_tcpNagleProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use TCP Nagle algorithm",
			"Specify whether to reduce the number of small TCP packets being sent"
			);

	if (propertySet & PropertyId.TcpReset)
		m_tcpResetProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use TCP reset",
			"Specify whether to drop TCP connections abruptly (with TCP RST)"
			);
}

SocketPropertySet.load (doc.Storage* storage)
{
	if (m_remoteAddressProp)
		m_remoteAddressProp.m_value = storage.readString ("address", DefaultRemoteAddress);

	if (m_remotePortProp)
		m_remotePortProp.m_value = storage.readInt ("remotePort", m_defaultRemotePort);

	if (m_useLocalAddressProp)
		m_useLocalAddressProp.m_value = storage.readBool ("useLocalAddress");

	if (m_adapterProp)
		m_adapterProp.m_currentIndex = storage.readInt ("adapterIdx");

	if (m_localPortProp)
		m_localPortProp.m_value = storage.readInt ("localPort", m_defaultLocalPort);

	if (m_reuseLocalAddressProp)
		m_reuseLocalAddressProp.m_value = storage.readBool ("reuseLocalAddress", false);

	if (m_tcpKeepAliveProp)
		m_tcpKeepAliveProp.m_value = storage.readBool ("tcpKeepAlive", Defaults.TcpKeepAlive);

	if (m_tcpNagleProp)
		m_tcpNagleProp.m_value = storage.readBool ("isNagleEnabled", Defaults.TcpNagle);

	if (m_tcpResetProp)
		m_tcpResetProp.m_value = storage.readBool ("closeKind", Defaults.TcpReset);
}

SocketPropertySet.save (doc.Storage* storage)
{
	if (m_remoteAddressProp)
		storage.writeString ("address", m_remoteAddressProp.m_value);

	if (m_remotePortProp)
		storage.writeInt ("remotePort", m_remotePortProp.m_value);

	if (m_useLocalAddressProp)
		storage.writeBool ("useLocalAddress", m_useLocalAddressProp.m_value);

	if (m_adapterProp)
		storage.writeInt ("adapterIdx", (int) m_adapterProp.m_currentIndex);

	if (m_localPortProp)
		storage.writeInt ("localPort", m_localPortProp.m_value);

	if (m_reuseLocalAddressProp)
		storage.writeBool ("reuseLocalAddress", m_reuseLocalAddressProp.m_value);

	if (m_tcpKeepAliveProp)
		storage.writeBool ("tcpKeepAlive", m_tcpKeepAliveProp.m_value);

	if (m_tcpNagleProp)
		storage.writeBool ("isNagleEnabled", m_tcpNagleProp.m_value);

	if (m_tcpResetProp)
		storage.writeBool ("closeKind", m_tcpResetProp.m_value);
}

SocketPropertySet.restoreDefaults ()
{
	if (m_remotePortProp)
		m_remotePortProp.m_value = m_defaultRemotePort;

	if (m_useLocalAddressProp)
		m_useLocalAddressProp.m_value = false;

	if (m_adapterProp)
		m_adapterProp.m_currentIndex = 0;

	if (m_localPortProp)
		m_localPortProp.m_value = m_defaultLocalPort;

	if (m_reuseLocalAddressProp)
		m_reuseLocalAddressProp.m_value = false;

	if (m_tcpKeepAliveProp)
		m_tcpKeepAliveProp.m_value = Defaults.TcpKeepAlive;

	if (m_tcpNagleProp)
		m_tcpNagleProp.m_value = Defaults.TcpNagle;

	if (m_tcpResetProp)
		m_tcpResetProp.m_value = Defaults.TcpReset;
}

//..............................................................................

io.SocketOptions getSocketOptions (
	io.SocketPropertySet* socketPropSet,
	io.BufferPropertySet* bufferPropSet
	)
{
	io.SocketOptions options;

	if (socketPropSet.m_reuseLocalAddressProp && socketPropSet.m_reuseLocalAddressProp.m_value)
		options |= io.SocketOptions.ReuseAddress;

	if (socketPropSet.m_tcpKeepAliveProp && socketPropSet.m_tcpKeepAliveProp.m_value)
		options |= io.SocketOptions.TcpKeepAlive;

	if (socketPropSet.m_tcpNagleProp && socketPropSet.m_tcpNagleProp.m_value)
		options |= io.SocketOptions.TcpNagle;

	if (socketPropSet.m_tcpResetProp && socketPropSet.m_tcpResetProp.m_value)
		options |= io.SocketOptions.TcpReset;

	if (bufferPropSet.m_keepReadBlockSizeProp && bufferPropSet.m_keepReadBlockSizeProp.m_value)
		options |= io.SocketOptions.KeepReadBlockSize;

	if (bufferPropSet.m_keepWriteBlockSizeProp && bufferPropSet.m_keepWriteBlockSizeProp.m_value)
		options |= io.SocketOptions.KeepWriteBlockSize;

	return options;
}

//..............................................................................

} // namespace io {
