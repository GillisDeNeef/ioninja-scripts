//..............................................................................
//
// Socket & network adapter user interface
//

import "gui_Base.jnc"
import "gui_PropertyGrid.jnc"
import "io_base.jncx"
import "io_Socket.jnc"
import "io_NetworkAdapter.jnc"
import "io_BufferUi.jnc"

namespace io {

//..............................................................................

enum NetworkAdapterUsage
{
	Connection,
	Listener,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

gui.EnumPropertyOption const* createNetworkAdapterOptionArray (NetworkAdapterUsage usage)
{
	size_t addressCount;
	io.NetworkAdapterDesc const* adapterList = io.createNetworkAdapterDescList (null, &addressCount);

	gui.EnumPropertyOption* optionArray;
	gui.EnumPropertyOption* option;

	switch (usage)
	{
	case NetworkAdapterUsage.Connection:
		addressCount++; // include 'Auto'
		optionArray = new gui.EnumPropertyOption [addressCount];
		option = optionArray;

		option.m_text = "Auto";
		option.m_value = null;
		option++;
		break;

	case NetworkAdapterUsage.Listener:
		static io.SocketAddress autoAddress_ip4 = { m_family = io.AddressFamily.Ip4 }
		static io.SocketAddress autoAddress_ip6 = { m_family = io.AddressFamily.Ip6 }

		addressCount += 2; // include 'All IPv4/IPv6 adapters'
		optionArray = new gui.EnumPropertyOption [addressCount];
		option = optionArray;

		option.m_text = "All IPv4 adapters";
		option.m_value = &autoAddress_ip4;
		option++;

		option.m_text = "All IPv6 adapters";
		option.m_value = &autoAddress_ip6;
		option++;
		break;
	}

	io.NetworkAdapterDesc const* adapter = adapterList;
	for (; adapter; adapter = adapter.m_next)
	{
		io.NetworkAdapterAddress const* address = adapter.m_address;
		for (; address; address = address.m_next, option++)
		{
			option.m_text = $"%1 - %2" (
				adapter.m_description,
				address.m_address.getString ()
				);

			option.m_value = &address.m_address;
		}
	}

	return optionArray;
}

//..............................................................................

gui.EnumProperty* createNetworkAdapterProperty (
	gui.PropertyGrid* propertyGrid,
	gui.GroupProperty* group = null,
	gui.Property* insertBefore = null,
	NetworkAdapterUsage usage,
	char const* name,
	char const* toolTipText
	)
{
	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray (usage);
	size_t optionCount = dynamic countof (optionArray);

	return propertyGrid.createEnumProperty (
		group,
		insertBefore,
		name,
		toolTipText,
		optionArray,
		optionCount
		);
}

gui.EnumProperty* createNetworkAdapterProperty (
	gui.PropertyGrid* propertyGrid,
	NetworkAdapterUsage usage,
	char const* name,
	char const* toolTipText
	)
{
	return createNetworkAdapterProperty (propertyGrid,,, usage, name, toolTipText);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

gui.ComboBox*
createNetworkAdapterComboBox (
	gui.ToolBar* toolBar,
	NetworkAdapterUsage usage,
	uint_t width = -1
	)
{
	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray (usage);
	size_t optionCount = dynamic countof (optionArray);

	gui.ComboBox* comboBox = toolBar.addComboBox (width);

	for (size_t i = 0; i < optionCount; i++)
		comboBox.addItem (
			optionArray [i].m_text,
			optionArray [i].m_value
			);

	return comboBox;
}

//..............................................................................

class SocketPropertySet
{
	bitflag enum PropertyId
	{
		RemoteAddress,
		RemotePort,
		UseLocalAddress,
		Adapter,
		LocalPort,
		TcpNagle,
		TcpReset,

		All =
			RemoteAddress |
			RemotePort |
			UseLocalAddress |
			Adapter |
			LocalPort |
			TcpNagle |
			TcpReset,
	}

	enum Defaults
	{
		RemotePort = 80,
		TcpNagle   = false,
		TcpReset   = false,
	}

	static char DefaultRemoteAddress [] = "ioninja.com";

	gui.StringProperty* m_remoteAddressProp;
	gui.IntProperty* m_remotePortProp;
	gui.BoolProperty* m_useLocalAddressProp;
	gui.EnumProperty* m_adapterProp;
	gui.IntProperty* m_localPortProp;
	gui.BoolProperty* m_tcpNagleProp;
	gui.BoolProperty* m_tcpResetProp;

	uint16_t m_defaultRemotePort = 80; // Defaults.RemotePort;

	createProperties (
		gui.PropertyGrid* propertyGrid,
		gui.GroupProperty* group = null,
		gui.Property* insertBefore = null,
		PropertyId propertySet = PropertyId.All
		);

	load (doc.Storage* storage);
	save (doc.Storage* storage);
	restoreDefaults ();
}

SocketPropertySet.createProperties (
	gui.PropertyGrid* propertyGrid,
	gui.GroupProperty* group,
	gui.Property* insertBefore,
	PropertyId propertySet
	)
{
	if (propertySet & PropertyId.RemoteAddress)
		m_remoteAddressProp = propertyGrid.createStringProperty (
			group,
			insertBefore,
			"Remote address",
			"Remote address to connect to (IP-address or host-name followed by ':' port)"
			);

	if (propertySet & PropertyId.RemotePort)
		m_remotePortProp = propertyGrid.createIntProperty (
			group,
			insertBefore,
			"Remote TCP port (default)",
			"Remote TCP port to connect to (if not specified in remote address)"
			);

	if (propertySet & PropertyId.UseLocalAddress)
		m_useLocalAddressProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use local address",
			"Bind socket to the specified local address before connect"
			);

	if (propertySet & PropertyId.Adapter)
		m_adapterProp = io.createNetworkAdapterProperty (
			propertyGrid,
			group,
			insertBefore,
			io.NetworkAdapterUsage.Connection,
			"Adapter",
			"Adapter to bind to before connect"
			);

	if (propertySet & PropertyId.LocalPort)
		m_localPortProp = propertyGrid.createIntProperty (
			group,,
			"Local TCP port",
			"Local TCP port to bind to before connect"
			);

	if (propertySet & PropertyId.TcpNagle)
		m_tcpNagleProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use TCP Nagle algorithm",
			"Specify whether to reduce the number of small TCP packets being sent"
			);

	if (propertySet & PropertyId.TcpReset)
		m_tcpResetProp = propertyGrid.createBoolProperty (
			group,
			insertBefore,
			"Use TCP reset",
			"Specify whether to drop TCP connections abruptly (with TCP RST)"
			);
}

SocketPropertySet.load (doc.Storage* storage)
{
	if (m_remoteAddressProp)
		m_remoteAddressProp.m_value = storage.readString ("address", DefaultRemoteAddress);

	if (m_remotePortProp)
		m_remotePortProp.m_value = storage.readInt ("remotePort", m_defaultRemotePort);

	if (m_useLocalAddressProp)
		m_useLocalAddressProp.m_value = storage.readBool ("useLocalAddress");

	if (m_adapterProp)
		m_adapterProp.m_currentIndex = storage.readInt ("adapterIdx");

	if (m_localPortProp)
		m_localPortProp.m_value = storage.readInt ("localPort");

	if (m_tcpNagleProp)
		m_tcpNagleProp.m_value = storage.readBool ("isNagleEnabledProp", Defaults.TcpNagle);

	if (m_tcpResetProp)
		m_tcpResetProp.m_value = storage.readBool ("closeKindProp", Defaults.TcpReset);
}

SocketPropertySet.save (doc.Storage* storage)
{
	if (m_remoteAddressProp)
		storage.writeString ("address", m_remoteAddressProp.m_value);

	if (m_remotePortProp)
		storage.writeInt ("remotePort", m_remotePortProp.m_value);

	if (m_useLocalAddressProp)
		storage.writeBool ("useLocalAddress", m_useLocalAddressProp.m_value);

	if (m_adapterProp)
		storage.writeInt ("adapterIdx", (int) m_adapterProp.m_currentIndex);

	if (m_localPortProp)
		storage.writeInt ("localPort", m_localPortProp.m_value);

	if (m_tcpNagleProp)
		storage.writeBool ("isNagleEnabledProp", m_tcpNagleProp.m_value);

	if (m_tcpResetProp)
		storage.writeBool ("closeKindProp", m_tcpResetProp.m_value);
}

SocketPropertySet.restoreDefaults ()
{
	if (m_remotePortProp)
		m_remotePortProp.m_value = m_defaultRemotePort;

	if (m_useLocalAddressProp)
		m_useLocalAddressProp.m_value = false;

	if (m_adapterProp)
		m_adapterProp.m_value = 0;

	if (m_localPortProp)
		m_localPortProp.m_value = 0;

	if (m_tcpNagleProp)
		m_tcpNagleProp.m_value = Defaults.TcpNagle;

	if (m_tcpResetProp)
		m_tcpResetProp.m_value = Defaults.TcpReset;
}

//..............................................................................

io.SocketOptions getSocketOptions (
	io.SocketPropertySet* socketPropSet,
	io.BufferPropertySet* bufferPropSet
	)
{
	io.SocketOptions options;

	if (socketPropSet.m_tcpNagleProp.m_value)
		options |= io.SocketOptions.TcpNagle;

	if (socketPropSet.m_tcpResetProp.m_value)
		options |= io.SocketOptions.TcpReset;

	if (bufferPropSet.m_keepReadBlockSizeProp.m_value)
		options |= io.SocketOptions.KeepReadBlockSize;

	if (bufferPropSet.m_keepWriteBlockSizeProp.m_value)
		options |= io.SocketOptions.KeepWriteBlockSize;

	return options;
}

//..............................................................................

} // namespace io {
