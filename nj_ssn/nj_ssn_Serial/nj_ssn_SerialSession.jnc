//.............................................................................
//
// Serial session
//

//.............................................................................

class SerialSession: doc.StreamSession
{
protected:
	enum ActionId
	{
		Open,
		Close,
		Dtr,
		Rts,
		_Count,
	};

protected:
	io.Serial* m_serial;
	uint_t m_syncId;

	gui.Action* m_actionTable [ActionId._Count];
	gui.EnumProperty* m_baudRateProp;
	gui.EnumProperty* m_dataBitsProp;
	gui.EnumProperty* m_stopBitsProp;
	gui.EnumProperty* m_parityProp;
	gui.EnumProperty* m_flowControlProp;
	gui.ComboBox* m_portCombo;
	char const* m_portName;

public:
	construct (doc.DocumentHost* documentHost);

	bool open () throws;
	close ();

	override size_t transmit (
		void const* p,
		size_t size
		) throws;

protected:
	createUi ();

	onReadyRead (io.Serial* sender);

	onStatusLineChanged (
		io.Serial* serial,
		io.SerialStatusLines lines,
		io.SerialStatusLines mask
		);

	reactor m_portUiReactor ();
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

SerialSession.construct (doc.DocumentHost* documentHost)
{
	basetype.construct (documentHost);
	documentHost.m_log.m_representer = SerialLogRepresenter.getSingleton ();
	createUi ();
}

SerialSession.createUi ()
{
	// toolbar

	m_documentHost.m_toolBar.addLabel ("Port: ");
	m_portCombo = m_documentHost.m_toolBar.addComboBox ();
	m_portCombo.addItem ("COM1");
	m_portCombo.addItem ("COM2");
	m_portCombo.addItem ("COM3");
	m_portCombo.addItem ("COM4");
	m_portCombo.addItem ("/dev/ttyS0");
	m_portCombo.addItem ("/dev/ttyS1");
	m_portCombo.addItem ("/dev/ttyS2");
	m_portCombo.addItem ("/dev/ttyS3");

	m_actionTable [ActionId.Open]  = m_documentHost.createAction ("Open", "connect.png");
	m_actionTable [ActionId.Open].m_onTriggered += open;

	m_actionTable [ActionId.Close] = m_documentHost.createAction ("Close", "pause.png");
	m_actionTable [ActionId.Close].m_isEnabled = false;

	m_documentHost.m_menu.addSeparator ();
	m_documentHost.m_toolBar.addSeparator ();

	m_actionTable [ActionId.Dtr] = m_documentHost.createCheckableAction ("DTR", true);
	m_actionTable [ActionId.Rts] = m_documentHost.createCheckableAction ("RTS", false);

	// property grid

	// baud

	static gui.EnumPropertyOption baudRateTable [] =
	{
		{ "9600 bps",   9600 },
		{ "19200 bps",  19200 },
		{ "38400 bps",  38400 },
		{ "115200 bps", 115200 },
	};

	m_baudRateProp = m_documentHost.createEnumProperty (
		"Baud rate",
		"Serial baud rate",
		baudRateTable,
		countof (baudRateTable)
		);

	m_baudRateProp.m_value = 38400;

	// data bits

	static gui.EnumPropertyOption dataBitsTable [] =
	{
		{ "7 bits", 7 },
		{ "8 bits", 8 },
	};

	m_dataBitsProp = m_documentHost.createEnumProperty (
		"Data bits",
		"Serial data bit count (word size)",
		dataBitsTable,
		countof (dataBitsTable)
		);

	m_dataBitsProp.m_value = 8;

	// stop bits

	static gui.EnumPropertyOption stopBitsTable [] =
	{
		{ "1 bit",    io.SerialStopBits._1 },
		{ "1.5 bits", io.SerialStopBits._15 },
		{ "2 bits",   io.SerialStopBits._2 },
	};

	m_stopBitsProp = m_documentHost.createEnumProperty (
		"Stop bits",
		"Serial stop bit count",
		stopBitsTable,
		countof (stopBitsTable)
		);

	m_stopBitsProp.m_value = io.SerialStopBits._1;

	// parity

	static gui.EnumPropertyOption parityTable [] =
	{
		{ "None",  io.SerialParity.None },
		{ "Odd",   io.SerialParity.Odd },
		{ "Even",  io.SerialParity.Even },
		{ "Mark",  io.SerialParity.Mark },
		{ "Space", io.SerialParity.Space },
	};

	m_parityProp = m_documentHost.createEnumProperty (
		"Parity",
		"Serial parity check",
		parityTable,
		countof (parityTable)
		);

	m_parityProp.m_value = io.SerialParity.None;

	// flow control

	static gui.EnumPropertyOption flowControlTable [] =
	{
		{ "None",                io.SerialFlowControl.None },
		{ "Hardware (RTS/CTS)",  io.SerialFlowControl.RtsCts },
		{ "Software (XON/XOFF)", io.SerialFlowControl.XOnXOff },
	};

	m_flowControlProp = m_documentHost.createEnumProperty (
		"Flow control",
		"Serial flow control",
		flowControlTable,
		countof (flowControlTable)
		);

	m_flowControlProp.m_value = io.SerialFlowControl.None;
}

bool SerialSession.open () throws
{
	close ();

	size_t index = m_portCombo.m_currentIndex;
	char const* name = m_portCombo.m_itemText [index];

	// open and configure

	m_serial = io.createSerial ();
	m_serial.open (name);
//	m_serial.m_baudRate = m_baudRateProp.m_value;
//	m_serial.m_dataBits = m_dataBitsProp.m_value;
//	m_serial.m_stopBits = (io.SerialStopBits) m_stopBitsProp.m_value;
//	m_serial.m_parity = (io.SerialParity) m_parityProp.m_value;
//	m_serial.m_flowControl = (io.SerialFlowControl) m_flowControlProp.m_value;

	SerialOpenParams params;
	params.m_baudRate = m_serial.m_baudRate;
	params.m_dataBits = m_serial.m_dataBits;
	params.m_stopBits = m_serial.m_stopBits;
	params.m_parity = m_serial.m_parity;
	params.m_flowControl = m_serial.m_flowControl;

	char const* p = $"$(params,B)$name";
	size_t size = jnc.getDataPtrSpan (p);
	m_documentHost.m_log.write (SerialLogPacketCode.PortOpened, p, size);

	m_serial.m_onReadyRead += onReadyRead ~(m_serial) @ m_documentHost.m_mainThreadScheduler;
	m_serial.m_onStatusLineChanged += onStatusLineChanged ~(m_serial) @ m_documentHost.m_mainThreadScheduler;
	m_portName = name;
	m_actionTable [ActionId.Close].m_isEnabled = true;
	m_portUiReactor.start ();
	return true;

catch:
	if (m_serial)
	{
		m_serial.close ();
		m_serial = null;
	}

	jnc.Error const* error = jnc.getLastError ();
	m_documentHost.m_log.write (
		SerialLogPacketCode.PortOpenError,
		error,
		error.m_size
		);
	return false;
}

SerialSession.close ()
{
	if (!m_serial)
		return;

	m_portUiReactor.stop ();
	m_actionTable [ActionId.Close].m_isEnabled = false;

	m_documentHost.m_log.write (
		SerialLogPacketCode.PortClosed,
		m_portName,
		strlen (m_portName) + 1
		);

	m_serial.close ();
	m_serial = null;
	m_portName = null;
}

size_t SerialSession.transmit (
	void const* p,
	size_t size
	) throws
{
	if (!m_serial)
		return -1;

	size_t result = try m_serial.write (p, size);
	if (result != -1)
		m_documentHost.m_log.write (SerialLogPacketCode.Tx, p, result);

	return result;
}

SerialSession.onReadyRead (io.Serial* serial)
{
	if (serial != m_serial)
		return;

	heap char buffer [512];
	size_t result = try m_serial.read (buffer, sizeof (buffer));
	if (result != -1)
		m_documentHost.m_log.write (SerialLogPacketCode.Rx, buffer, result);
}

SerialSession.onStatusLineChanged (
	io.Serial* serial,
	io.SerialStatusLines lines,
	io.SerialStatusLines mask
	)
{
	if (serial != m_serial)
		return;

	char const* p = $"$(lines, B)$(mask, B)";
	size_t size = jnc.getDataPtrSpan (p);
	m_documentHost.m_log.write (SerialLogPacketCode.StatusLineChanged, p, size);
}

reactor SerialSession.m_portUiReactor ()
{
	onevent (bindingof (m_baudRateProp.m_value)) ()
	{
		uint_t value = m_baudRateProp.m_value;
		m_serial.m_baudRate = value;
		m_documentHost.m_log.write (SerialLogPacketCode.BaudRateChanged, &value, sizeof (value));
	}

	onevent (bindingof (m_dataBitsProp.m_value)) ()
	{
		uint_t value = m_dataBitsProp.m_value;
		m_serial.m_dataBits = value;
		m_documentHost.m_log.write (SerialLogPacketCode.DataBitsChanged, &value, sizeof (value));
	}

	onevent (bindingof (m_stopBitsProp.m_value)) ()
	{
		io.SerialStopBits value = (io.SerialStopBits) m_stopBitsProp.m_value;
		m_serial.m_stopBits = value;
		m_documentHost.m_log.write (SerialLogPacketCode.StopBitsChanged, &value, sizeof (value));
	}

	onevent (bindingof (m_parityProp.m_value)) ()
	{
		io.SerialParity value = (io.SerialParity) m_parityProp.m_value;
		m_serial.m_parity = value;
		m_documentHost.m_log.write (SerialLogPacketCode.ParityChanged, &value, sizeof (value));
	}

	onevent (bindingof (m_flowControlProp.m_value)) ()
	{
		io.SerialFlowControl value = (io.SerialFlowControl) m_flowControlProp.m_value;
		m_serial.m_flowControl = value;
		m_documentHost.m_log.write (SerialLogPacketCode.FlowControlChanged, &value, sizeof (value));
	}

	onevent m_actionTable [ActionId.Dtr].m_onTriggered ()
	{
		bool value = m_actionTable [ActionId.Dtr].m_isChecked;
		m_serial.m_dtr = value;
		m_documentHost.m_log.write (SerialLogPacketCode.DtrChanged, &value, sizeof (value));
	}

	onevent m_actionTable [ActionId.Rts].m_onTriggered ()
	{
		bool value = m_actionTable [ActionId.Rts].m_isChecked;
		m_serial.m_rts = value;
		m_documentHost.m_log.write (SerialLogPacketCode.RtsChanged, &value, sizeof (value));
	}

	onevent m_actionTable [ActionId.Close].m_onTriggered ()
	{
		close ();
	}
}

//.............................................................................
