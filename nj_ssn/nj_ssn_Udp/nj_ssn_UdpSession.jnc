class UdpSession: doc.StreamSession
{
	gui.ComboBox* m_remoteAddressCombo;
	gui.IntProperty* m_remotePortProp;
	gui.IntProperty* m_localPortProp;
	
	io.Socket* m_socket;
	io.SocketAddress m_remoteAddress;
	int m_localPort;
	
	construct (doc.DocumentHost* documentHost)
	{
		basetype.construct(documentHost);
		
		printf ("UdpSession.construct (this = %x, TID = %x)\n", this, jnc.getCurrentThreadId ());
		
		documentHost.m_log.m_representer = new UdpLogRepresenter;
		
		createGui ();
	}

	void createGui()
	{
		m_documentHost.m_toolBar.addLabel ("Remote address: ");
		m_remoteAddressCombo = m_documentHost.m_toolBar.addComboBox (-1);
		m_remoteAddressCombo.m_isEditable = true;
		m_remoteAddressCombo.m_editText = "192.168.1.11";
		
		gui.Action* action = m_documentHost.createAction("Open socket", "connect.png");
		action.m_onTriggered += openSocket;
		
		action = m_documentHost.createAction("Close socket", "disconnect.png");
		action.m_onTriggered += closeSocket;
		
		m_remotePortProp = m_documentHost.createIntProperty ("Remote port", "Remote port");
		m_remotePortProp.m_value = 12345;
		
		m_localPortProp = m_documentHost.createIntProperty ("Local port", "Local port");
		m_localPortProp.m_value = 12345;
	}
	
	void openSocket ()
	{
		closeSocket ();

		if (!try io.parseSocketAddress ($"$(m_remoteAddressCombo.m_editText):$(m_remotePortProp.m_value)", &m_remoteAddress))
		{
			reportError ();
			return;
		}

		io.SocketAddress localAddress;
		if (!try io.parseSocketAddress ($"0.0.0.0:$(m_localPortProp.m_value)", &localAddress))
		{
			reportError ();
			return;
		}
		
		m_socket = io.createSocket ();
		m_socket.m_onSocketEvent += onSocketEvent;
				
		if (!try m_socket.open (io.Protocol.Udp, &localAddress))
		{
			reportError ();
			return;
		}
				
		m_localPort = m_localPortProp.m_value;
		char* port = $"$(m_localPort)";
		m_documentHost.m_log.write (PacketCode.Open, (void*) port, strlen (port));
	}
	
	void closeSocket ()
	{
		if (!m_socket)
			return;
	
		m_socket.close ();
		m_socket = null;

		char* port = $"$(m_localPort)";
		m_documentHost.m_log.write (PacketCode.Close, (void*) port, strlen(port));
	}
	
	void onSocketEvent(io.SocketEventParams const* params)
	{
		printf ("UdpSession.onSocketEvent (TID = %x)\n", jnc.getCurrentThreadId ());

		if (params.m_sender != (io.Socket*) m_socket)
			return;
			
		switch (params.m_eventKind)
		{
			case io.SocketEvent.IncomingData:
				heap char buffer [512];
				size_t result = try m_socket.recv (buffer, sizeof (buffer));
				if (result != -1)
					m_documentHost.m_log.write (PacketCode.Rx, buffer, result);
				break;
		}
	}
	
	override size_t transmit (void const* p, size_t size) throws
	{
		if (m_socket && m_socket.m_isOpen)
		{
			if (try m_socket.sendTo (p, size, &m_remoteAddress))
			{
				const char* text = io.formatSocketAddress (&m_remoteAddress);
				m_documentHost.m_log.write(PacketCode.Tx, p, size);
			}
			else
			{
				reportError ();
			}
		}
		
		return 0;
	}
	
	void reportError()
	{
		jnc.Error const* error = jnc.getLastError ();
		m_documentHost.m_log.write (PacketCode.Error, error, error.m_size);
	}
}