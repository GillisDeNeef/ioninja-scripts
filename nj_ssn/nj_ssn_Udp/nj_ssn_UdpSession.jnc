class UdpSession: doc.StreamSession
{
	gui.EnumPropertyOption m_ifaceTable [] =
	{
		{ "0.0.0.0",   0 },
		{ "127.0.0.1", 1 },
	};

	gui.ComboBox* m_localPortCombo;
	gui.Action* m_openSocketAction;
	gui.Action* m_closeSocketAction;
	gui.ComboBox* m_remoteAddressCombo;
	gui.EnumProperty* m_ifaceProp;
	
	io.Socket* m_socket;
	bindable bool m_isSocketOpen;
		
	construct (doc.DocumentHost* documentHost)
	{
		basetype.construct(documentHost);
		
		printf ("UdpSession.construct (this = %x, TID = %x)\n", this, jnc.getCurrentThreadId ());
		
		documentHost.m_log.m_representer = new UdpLogRepresenter;
		
		createGui ();
	}

	void createGui()
	{
		m_documentHost.m_toolBar.addLabel ("Local port: ");
		m_localPortCombo = m_documentHost.m_toolBar.addComboBox ();
		m_localPortCombo.m_isEditable = true;
		m_localPortCombo.addItem ("12345");

		m_openSocketAction = m_documentHost.createAction("Open socket", "open.png");
		m_openSocketAction.m_onTriggered += openSocket;
		
		m_closeSocketAction = m_documentHost.createAction("Close socket", "close.png");
		m_closeSocketAction.m_onTriggered += closeSocket;

		m_documentHost.m_toolBar.addSeparator ();

		m_documentHost.m_toolBar.addLabel ("Remote address: ");
		m_remoteAddressCombo = m_documentHost.m_toolBar.addComboBox (-1);
		m_remoteAddressCombo.m_isEditable = true;
		m_remoteAddressCombo.addItem("192.168.1.11:12345");
		
		m_ifaceProp = m_documentHost.createEnumProperty (
			"Interface",
			"Interface",
			m_ifaceTable,
			countof (m_ifaceTable));
		
		m_uiReactor.start();
	}
	
	reactor m_uiReactor ()
	{
		m_openSocketAction.m_isEnabled = !m_isSocketOpen;
		m_closeSocketAction.m_isEnabled = m_isSocketOpen;
		m_localPortCombo.m_isEnabled = !m_isSocketOpen;
		m_ifaceProp.m_isEnabled = !m_isSocketOpen;
	}
	
	void openSocket ()
	{
		closeSocket ();
		
		const char* iface = m_ifaceTable [m_ifaceProp.m_value].m_text;
		const char* port = m_localPortCombo.m_editText;

		io.SocketAddress localAddress;
		if (!try io.parseSocketAddress ($"$iface:$port", &localAddress))
		{
			reportError ();
			return;
		}
		
		m_socket = io.createSocket ();
		m_socket.m_onSocketEvent += onSocketEvent;
				
		if (!try m_socket.open (io.Protocol.Udp, &localAddress))
		{
			reportError ();
			return;
		}
				
		m_documentHost.m_log.write (PacketCode.Open, (void*) port, strlen (port));
		
		m_isSocketOpen = true;
	}
	
	void closeSocket ()
	{
		if (!m_socket)
			return;
	
		m_socket.close ();
		m_socket = null;
	
		char const* port = m_localPortCombo.m_editText;
		m_documentHost.m_log.write (PacketCode.Close, (void*) port, sizeof (port));
		
		m_isSocketOpen = false;
	}

	void onSocketEvent(io.SocketEventParams const* params)
	{
		printf ("UdpSession.onSocketEvent (TID = %x)\n", jnc.getCurrentThreadId ());

		if (params.m_sender != (io.Socket*) m_socket)
			return;
			
		switch (params.m_eventKind)
		{
			case io.SocketEvent.IncomingData:
				heap char buffer [512];
				size_t size = try m_socket.recv (buffer, sizeof (buffer));
				if (size != -1)
					m_documentHost.m_log.write (PacketCode.Rx, buffer, size);
				break;
		}
	}
	
	override size_t transmit (void const* p, size_t size) throws
	{
		if (m_isSocketOpen)
		{
			io.SocketAddress remoteAddress;
			if (!try io.parseSocketAddress (m_remoteAddressCombo.m_editText, &remoteAddress))
			{
				reportError ();
				return 0;
			}
		
			if (try m_socket.sendTo (p, size, &remoteAddress))
			{
				const char* text = io.formatSocketAddress (&remoteAddress);
				m_documentHost.m_log.write(PacketCode.Tx, p, size);
			}
			else
			{
				reportError ();
			}
		}
		
		return 0;
	}
		
	void reportError()
	{
		jnc.Error const* error = jnc.getLastError ();
		m_documentHost.m_log.write (PacketCode.Error, error, error.m_size);
	}
}