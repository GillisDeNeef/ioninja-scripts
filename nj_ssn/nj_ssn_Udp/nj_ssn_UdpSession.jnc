class UdpSession: doc.StreamSession
{
	gui.EnumPropertyOption m_ifaceTable [] =
	{
		{ "0.0.0.0",   0 },
		{ "127.0.0.1", 1 },
	};

	gui.ComboBox* m_localPortCombo;
	gui.Action* m_openSocketAction;
	gui.Action* m_closeSocketAction;
	gui.ComboBox* m_remoteAddressCombo;
	gui.EnumProperty* m_ifaceProp;
	
	io.Socket* m_socket;
	bindable bool m_isSocketOpen;
		
	construct (doc.DocumentHost* documentHost)
	{
		basetype.construct(documentHost);

		documentHost.m_log.m_representer = static new UdpLogRepresenter;
		
		m_socket = io.createSocket ();
		m_socket.m_onSocketEvent += onSocketEvent;

		createGui ();
	}

	void createGui()
	{
		m_documentHost.m_toolBar.addLabel ("Local port: ");
		m_localPortCombo = m_documentHost.m_toolBar.addComboBox ();
		m_localPortCombo.m_isEditable = true;
		m_localPortCombo.addItem ("12345");

		m_openSocketAction = m_documentHost.createAction("Open socket", "open.png");
		m_openSocketAction.m_onTriggered += openSocket;
		
		m_closeSocketAction = m_documentHost.createAction("Close socket", "close.png");
		m_closeSocketAction.m_onTriggered += closeSocket;

		m_documentHost.m_toolBar.addSeparator ();

		m_documentHost.m_toolBar.addLabel ("Remote address: ");
		m_remoteAddressCombo = m_documentHost.m_toolBar.addComboBox (-1);
		m_remoteAddressCombo.m_isEditable = true;
		m_remoteAddressCombo.addItem("192.168.1.11:12345");
		
		m_ifaceProp = m_documentHost.createEnumProperty (
			"Interface",
			"Interface",
			m_ifaceTable,
			countof (m_ifaceTable));
		
		m_uiReactor.start();
	}
	
	reactor m_uiReactor ()
	{
		m_openSocketAction.m_isEnabled = !m_isSocketOpen;
		m_closeSocketAction.m_isEnabled = m_isSocketOpen;
		m_localPortCombo.m_isEnabled = !m_isSocketOpen;
		m_ifaceProp.m_isEnabled = !m_isSocketOpen;
	}
	
	void openSocket ()
	{
		closeSocket ();
		
		const char* iface = m_ifaceTable [m_ifaceProp.m_value].m_text;
		const char* port = m_localPortCombo.m_editText;

		io.SocketAddress localAddress;
		if (!try io.parseSocketAddress ($"$iface:$port", &localAddress))
		{
			reportError ();
			return;
		}	
			
		if (!try m_socket.open (io.Protocol.Udp, &localAddress))
		{
			reportError ();
			return;
		}
				
		m_documentHost.m_log.write (RecordCode.Open, port, strlen (port));
		
		m_isSocketOpen = true;
	}
	
	void closeSocket ()
	{
		if (!m_isSocketOpen)
			return;
	
		m_socket.close ();
	
		char const* port = m_localPortCombo.m_editText;
		m_documentHost.m_log.write (RecordCode.Close, port, strlen (port));
		
		m_isSocketOpen = false;
	}

	void onSocketEvent(io.SocketEventParams const* params)
	{
		if (params.m_syncId != m_socket.m_syncId)
			return;
			
		switch (params.m_eventKind)
		{
			case io.SocketEvent.IncomingData:
				io.SocketAddress remoteAddress;
				heap char buffer [512];
				size_t size = try m_socket.recvFrom (buffer, sizeof (buffer), &remoteAddress);
				if (size != -1)
				{
					void* data = memcat (&remoteAddress, sizeof (io.SocketAddress), buffer, size);
					size_t dataSize = sizeof (io.SocketAddress) + size;
					
					m_documentHost.m_log.write (RecordCode.Rx, data, dataSize);
				}
				break;
		}
	}
	
	override size_t transmit (void const* p, size_t size) throws
	{
		if (m_isSocketOpen)
		{
			io.SocketAddress remoteAddress;
			if (!try io.parseSocketAddress (m_remoteAddressCombo.m_editText, &remoteAddress))
			{
				reportError ();
				return 0;
			}
		
			if (try m_socket.sendTo (p, size, &remoteAddress))
			{
				void* data = memcat (&remoteAddress, sizeof (io.SocketAddress), p, size);
				size_t dataSize = sizeof (io.SocketAddress) + size;

				m_documentHost.m_log.write(RecordCode.Tx, data, dataSize);
			}
			else
			{
				reportError ();
			}
		}
		
		return 0;
	}
		
	void reportError()
	{
		jnc.Error const* error = jnc.getLastError ();
		m_documentHost.m_log.write (RecordCode.Error, error, error.m_size);
	}
}