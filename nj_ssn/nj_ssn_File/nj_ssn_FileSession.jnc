//.............................................................................
//
// Generic file session
//

//.............................................................................

class FileSession: doc.Session
{
protected:
	enum State
	{
		Closed,
		Opened,
	}

	enum Access
	{
		ReadWrite,
		ReadOnly,
		WriteOnly,
	}

	enum ActionId
	{
		Open,
		Close,
		_Count,
	}

protected:
	// file

	State bindable m_state;
	Access m_access;
	io.FileStream* m_file;
	char const* m_fileName;

	// toolbar & menu

	gui.Action* m_actionTable [ActionId._Count];
	gui.ComboBox* m_fileNameCombo;
	
	// property grid

	gui.StringProperty* m_fileNameProp;
	gui.EnumProperty* m_accessProp;

public:
	construct (doc.DocumentHost* documentHost);

	bool open () throws;
	close ();

	override void load (doc.Storage* storage);
	override void save (doc.Storage* storage);
	override void updateProperties ();
	override bool applyProperties () throws;
	override void restoreDefaultProperties ();

	override size_t transmit (
		void const* p,
		size_t size
		) throws;

protected:
	createUi ();

	onFileStreamEvent (io.FileStreamEventParams const* params);

	reactor m_uiReactor ();
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

FileSession.construct (doc.DocumentHost* documentHost)
{
	basetype.construct (documentHost);
	
	documentHost.m_log.m_representer = static new FileLogRepresenter;

	m_state = State.Closed;
	m_access = Access.ReadWrite;
	m_file = io.createFileStream ();
	m_file.m_onFileStreamEvent += onFileStreamEvent @ m_documentHost.m_mainThreadScheduler;

	createUi ();
}

FileSession.createUi ()
{
	m_documentHost.m_toolBar.addLabel ("File:");
	m_fileNameCombo = m_documentHost.m_toolBar.addComboBox (-1);
	m_fileNameCombo.m_isEditable = true;

	m_actionTable [ActionId.Open] = m_documentHost.createAction ("Open", "open.png");
	m_actionTable [ActionId.Open].m_onTriggered += open;

	m_actionTable [ActionId.Close] = m_documentHost.createAction ("Close", "close.png");
	m_actionTable [ActionId.Close].m_onTriggered += close;
	m_actionTable [ActionId.Close].m_isEnabled = false;

	m_fileNameProp = m_documentHost.createStringProperty (
		"File name",
		"Specify the file name to open"
		);

	static gui.EnumPropertyOption ifaceTable [] =
	{
		{ "Read/Write",  Access.ReadWrite },
		{ "Read-only",   Access.ReadOnly  },
		{ "Write-only",  Access.WriteOnly },
	};

	m_accessProp = m_documentHost.createEnumProperty (
		"Access mode",
		"Access mode for the file",
		ifaceTable,
		countof (ifaceTable)
		);

	m_uiReactor.start ();
}

bool FileSession.open () throws
{
	char const* fileName = m_fileNameCombo.m_editText;
	
	m_file.open (fileName);
	m_documentHost.m_log.write (FileLogRecordCode.Opened, fileName, strlen (fileName));
	m_fileNameCombo.addHistoryItem (fileName);
	
	m_fileName = fileName;
	m_state = State.Opened;
	return true;

catch:
	jnc.Error const* error = jnc.getLastError ();
	m_documentHost.m_log.write (
		FileLogRecordCode.OpenError,
		error,
		error.m_size
		);

	m_file.close ();
	return false;
}

FileSession.close ()
{
	if (m_state != State.Opened)
		return;

	m_documentHost.m_log.write (FileLogRecordCode.Closed, m_fileName, strlen (m_fileName));
	m_file.close ();
	m_state = State.Opened;
}

void FileSession.load (doc.Storage* storage)
{
	m_fileNameCombo.m_editText = storage.readString ("fileName");
	m_accessProp.m_value = storage.readInt ("access");
}

void FileSession.save (doc.Storage* storage)
{
	storage.writeString ("fileName", m_fileNameCombo.m_editText);
	storage.writeInt ("access", m_accessProp.m_value);
}

void FileSession.updateProperties ()
{
	m_fileNameProp.m_value = m_fileNameCombo.m_editText;
}

bool FileSession.applyProperties () throws
{
	m_fileNameCombo.m_editText = m_fileNameProp.m_value;
	return true;
}

void FileSession.restoreDefaultProperties ()
{
	m_fileNameProp.m_value = "\\\\.\\pipe\\mypipe0";
	m_accessProp.m_value = Access.ReadWrite;
}

size_t FileSession.transmit (
	void const* p,
	size_t size
	) throws
{
	if (m_state != State.Opened)
		return -1;

	size_t result = try m_file.write (p, size);
	if (result != -1)
		m_documentHost.m_log.write (log.StdRecordCode.Tx, p, result);

	return result;
}

FileSession.onFileStreamEvent (io.FileStreamEventParams const* params)
{
	if (params.m_syncId != m_file.m_syncId)
		return;

	switch (params.m_eventKind)
	{
	case io.FileStreamEvent.Eof:
	case io.FileStreamEvent.ReadError:
		m_documentHost.m_log.write (FileLogRecordCode.Eof);
		m_file.close ();
		m_state = State.Closed;
		break;
		
	case io.FileStreamEvent.IncomingData:
		heap char buffer [512];
		size_t result = try m_file.read (buffer, sizeof (buffer));
		if (result != -1)
			m_documentHost.m_log.write (log.StdRecordCode.Rx, buffer, result);
		break;	
	}
}

reactor FileSession.m_uiReactor ()
{
	m_documentHost.m_title = $"File $(m_fileNameCombo.m_editText)";
	m_actionTable [ActionId.Close].m_isEnabled = m_state == State.Opened;
}

//.............................................................................
