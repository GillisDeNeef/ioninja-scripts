//.............................................................................
//
// Pipe Listener session
//

//.............................................................................

class PipeListenerSession: doc.StreamSession
{
protected:
	enum ActionId
	{
		Listen,
		StopListen,
		Disconnect,
		_Count,
	};

protected:
	io.NamedPipe* m_listenerPipe;
	io.FileStream* m_connectionPipe;
	
	gui.Action* m_actionTable [ActionId._Count];
	gui.BoolProperty* m_overrideOldConnectionProp;
	gui.ComboBox* m_nameCombo;
	
	char const* m_pipeName;

public:
	construct (doc.DocumentHost* documentHost);

	bool listen () throws;
	stopListen ();
	disconnect ();

	override size_t transmit (
		void const* p,
		size_t size
		) throws;

protected:
	closeListenerPipe ();
	closeConnectionPipe ();
	onIncomingConnection ();
	onConnectionPipeEvent (io.FileStreamEventParams const* params);

	createUi ();
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

PipeListenerSession.construct (doc.DocumentHost* documentHost)
{
	basetype.construct (documentHost);
	documentHost.m_log.m_representer = PipeListenerLogRepresenter.getSingleton ();	
	createUi ();
}

PipeListenerSession.createUi ()
{
	// toolbar

	m_documentHost.m_toolBar.addLabel ("Name: ");
	m_nameCombo = m_documentHost.m_toolBar.addComboBox (-1);
	m_nameCombo.m_isEditable = true;
	m_nameCombo.m_editText = "\\\\.\\pipe\\mypipe0";

	m_actionTable [ActionId.Listen] = m_documentHost.createAction ("Listen", "listen.png");
	m_actionTable [ActionId.Listen].m_onTriggered += listen;

	m_actionTable [ActionId.StopListen] = m_documentHost.createAction ("Stop listening", "pause.png");
	m_actionTable [ActionId.StopListen].m_onTriggered += stopListen;
	m_actionTable [ActionId.StopListen].m_isEnabled = false;

	m_actionTable [ActionId.Disconnect] = m_documentHost.createAction ("Disconnect", "disconnect.png");
	m_actionTable [ActionId.Disconnect].m_onTriggered += disconnect;
	m_actionTable [ActionId.Disconnect].m_isEnabled = false;

	static gui.EnumPropertyOption ifaceTable [] =
	{
		{ "0.0.0.0",   0x00000000 },
		{ "127.0.0.1", 0x7f000001 },
	};

	m_overrideOldConnectionProp = m_documentHost.createBoolProperty (
		"Override Connections",
		"Accept incoming connection even if already connected"
		);
	m_overrideOldConnectionProp.m_value = true;
}

bool PipeListenerSession.listen () throws
{
	stopListen ();

	char const* name = m_nameCombo.m_editText;

	m_listenerPipe = io.createNamedPipe ();
	m_listenerPipe.m_onIncomingConnection += onIncomingConnection @ m_documentHost.m_mainThreadScheduler;
	m_listenerPipe.open (name);

	m_documentHost.m_log.write (
		PipeListenerLogPacketCode.Listening,
		name,
		strlen (name)
		);

	m_pipeName = name;
	m_actionTable [ActionId.StopListen].m_isEnabled = true;
	return true;

catch:
	if (m_listenerPipe)
	{
		m_listenerPipe.close ();
		m_listenerPipe = null;
	}

	jnc.Error const* error = jnc.getLastError ();
	m_documentHost.m_log.write (
		PipeListenerLogPacketCode.ListenError,
		error,
		error.m_size
		);
	return false;
}

PipeListenerSession.stopListen ()
{
	if (!m_listenerPipe)
		return;

	m_documentHost.m_log.write (
		PipeListenerLogPacketCode.ListenStopped,
		m_pipeName,
		strlen (m_pipeName)
		);
	
	closeListenerPipe ();
}

PipeListenerSession.disconnect ()
{
	if (!m_connectionPipe)
		return;

	m_documentHost.m_log.write (PipeListenerLogPacketCode.ClientDisconnected);
	closeConnectionPipe ();
}

size_t PipeListenerSession.transmit (
	void const* p,
	size_t size
	) throws
{
	if (!m_connectionPipe)
		return -1;

	size_t result = try m_connectionPipe.write (p, size);
	if (result != -1)
		m_documentHost.m_log.write (log.StdPacketCode.Tx, p, result);

	return result;
}

PipeListenerSession.closeListenerPipe ()
{
	m_actionTable [ActionId.StopListen].m_isEnabled = false;
	m_listenerPipe.close ();
	m_listenerPipe = null;
}

PipeListenerSession.closeConnectionPipe ()
{
	m_actionTable [ActionId.Disconnect].m_isEnabled = false;
	m_connectionPipe.close ();
	m_connectionPipe = null;
}

PipeListenerSession.onIncomingConnection ()
{
	io.FileStream* pipe = try m_listenerPipe.accept ();
	if (!pipe)
		return;

	if (m_connectionPipe)
		if (!m_overrideOldConnectionProp.m_value)
		{
			pipe.close ();
			m_documentHost.m_log.write (PipeListenerLogPacketCode.ClientRejected);
			return;
		}

	disconnect ();

	m_documentHost.m_log.write (PipeListenerLogPacketCode.ClientConnected);

	m_connectionPipe = pipe;
	m_connectionPipe.m_onFileStreamEvent += onConnectionPipeEvent @ m_documentHost.m_mainThreadScheduler;
	
	m_actionTable [ActionId.Disconnect].m_isEnabled = true;
}

PipeListenerSession.onConnectionPipeEvent (io.FileStreamEventParams const* params)
{
	if (params.m_sender != m_connectionPipe)
		return;

	switch (params.m_eventKind)
	{
	case io.FileStreamEvent.Eof:
	case io.FileStreamEvent.ReadError:
		m_documentHost.m_log.write (PipeListenerLogPacketCode.ClientDisconnected);
		closeConnectionPipe ();
		break;

	case io.FileStreamEvent.IncomingData:
		heap char buffer [512];
		size_t result = try m_connectionPipe.read (buffer, sizeof (buffer));
		if (result != -1)
			m_documentHost.m_log.write (log.StdPacketCode.Rx, buffer, result);
		break;
	}
}

//.............................................................................
