//.............................................................................
//
// Ninja document model
//

namespace doc {

//.............................................................................

opaque class Storage
{
	char const* autoget property m_directory;

	void clear ();

	bool readBool (char const* name)
	{
		return readInt (name) != 0;
	}

	void writeBool (
		char const* name, 
		bool value
		)
	{
		return writeInt (name, value);
	}

	int readInt (char const* name);

	void writeInt (
		char const* name, 
		int value
		);

	char const* readString (char const* name);

	void writeString (
		char const* name, 
		nullable char const* value
		);
}

//.............................................................................

class DocumentHost
{
	char const* autoget property m_title;
	
	gui.Menu* m_menu;
	gui.ToolBar* m_toolBar;
	gui.PropertyGrid* m_propertyGrid;
	log.Log* m_log;
	jnc.Scheduler* m_mainThreadScheduler;

	gui.Action* createAction (
		char const* text,
		nullable char const* iconFileName = null
		);

	gui.Action* createCheckableAction (
		char const* text,
		bool isChecked = false
		);

	gui.BoolProperty* createBoolProperty (
		char const* name,
		char const* toolTipText
		);

	gui.IntProperty* createIntProperty (
		char const* name,
		char const* toolTipText
		);

	gui.StringProperty* createStringProperty (
		char const* name,
		char const* toolTipText
		);

	gui.EnumProperty* createEnumProperty (
		char const* name,
		char const* toolTipText,
		gui.EnumPropertyOption const* optionArray,
		size_t count
		);

	gui.EnumProperty* createNetworkAdapterProperty (
		char const* name,
		char const* toolTipText
		);
}

//.............................................................................

enum DocumentKind
{
	Log,
	Session,
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class Document
{
	DocumentKind dconst m_documentKind;
	DocumentHost* dconst m_documentHost;

	construct (
		DocumentKind documentKind,
		DocumentHost* documentHost
		)
	{
		m_documentKind = documentKind;
		m_documentHost = documentHost;
	}
	
	virtual void load (Storage* storage)
	{		
	}

	virtual void save (Storage* storage)
	{		
	}

	virtual void updateProperties ()
	{		
	}

	virtual bool applyProperties () throws
	{
		return true;
	}

	virtual void restoreDefaultProperties ()
	{		
	}

}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class Log: Document
{
	construct (DocumentHost* documentHost)
	{
		basetype.construct (DocumentKind.Log, documentHost);
	}
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class Session: Document
{
	construct (DocumentHost* documentHost)
	{
		basetype.construct (DocumentKind.Session, documentHost);
	}

	virtual size_t transmit (
		void const* p,
		size_t size
		) throws
	{
		return 0;
	}
}

//.............................................................................

gui.Action* DocumentHost.createAction (
	char const* text,
	nullable char const* iconFileName
	)
{
	gui.Icon* icon;
	if (iconFileName)
		icon = gui.loadIcon (iconFileName);

	gui.Action* action = gui.createAction (text, icon);
	m_menu.addAction (action);
	m_toolBar.addAction (action);
	return action;
}

gui.Action* DocumentHost.createCheckableAction (
	char const* text,
	bool isChecked
	)
{
	gui.Action* action = createAction (text);
	action.m_isCheckable = true;
	action.m_isChecked = isChecked;
	return action;
}

gui.BoolProperty* DocumentHost.createBoolProperty (
	char const* name,
	char const* toolTipText
	)
{
	gui.BoolProperty* prop = gui.createBoolProperty (name);
	prop.m_toolTipText = toolTipText;
	m_propertyGrid.addProperty (prop);
	return prop;
}

gui.IntProperty* DocumentHost.createIntProperty (
	char const* name,
	char const* toolTipText
	)
{
	gui.IntProperty* prop = gui.createIntProperty (name);
	prop.m_toolTipText = toolTipText;
	m_propertyGrid.addProperty (prop);
	return prop;
}

gui.StringProperty* DocumentHost.createStringProperty (
	char const* name,
	char const* toolTipText
	)
{
	gui.StringProperty* prop = gui.createStringProperty (name);
	prop.m_toolTipText = toolTipText;
	m_propertyGrid.addProperty (prop);
	return prop;
}

gui.EnumProperty* DocumentHost.createEnumProperty (
	char const* name,
	char const* toolTipText,
	gui.EnumPropertyOption const* optionArray,
	size_t count
	)
{
	gui.EnumProperty* prop = gui.createEnumProperty (name);
	prop.m_toolTipText = toolTipText;
	prop.setOptions (optionArray, count);
	m_propertyGrid.addProperty (prop);
	return prop;
}

gui.EnumProperty* DocumentHost.createNetworkAdapterProperty (
	char const* name,
	char const* toolTipText
	)
{
	size_t adapterCount;
	io.NetworkAdapter const* adapterList = io.createNetworkAdapterList (&adapterCount);

	adapterCount += 2; // include 'All adapters' and 'Loopback adapter'
	gui.EnumPropertyOption* adapterOptionArray = new gui.EnumPropertyOption [adapterCount];

	gui.EnumPropertyOption* adapterOption = adapterOptionArray;	
	adapterOption.m_text = "0.0.0.0 (All adapters)"; 
	adapterOption.m_value = 0;
	adapterOption++;	

	adapterOption.m_text = "127.0.0.1 (Loopback adapter)"; 
	adapterOption.m_value = 0x7f000001;
	adapterOption++;	

	io.NetworkAdapter const* adapter = adapterList;
	for (; adapter; adapter = adapter->m_next, adapterOption++)
	{
		adapterOption.m_text = jnc.format (
			"%s (%s)", 
			io.formatAddress_Ip4 (&adapter->m_address.m_address),
			adapter->m_description
			);

		adapterOption.m_value = adapter->m_address.m_address.m_i32;
	}

	return createEnumProperty (
		name,
		toolTipText,
		adapterOptionArray,
		adapterCount
		);
}

//.............................................................................

} // namespace doc {
